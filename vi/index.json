[{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/","title":"Báo cáo thực tập","tags":[],"description":"","content":"Báo cáo thực tập Thông tin sinh viên: Họ và tên: Lê Duy Khánh\nSố điện thoại: 0389430144\nEmail: ldk11072003@gmail.com\nTrường: Đại học Sài Gòn\nNgành: Công nghệ thông tin\nLớp: DCT1216\nCông ty thực tập: Công ty TNHH Amazon Web Services Vietnam\nVị trí thực tập: FCJ Cloud Intern\nThời gian thực tập: Từ ngày 08/09/2025 đến ngày 30/11/2025\nNội dung báo cáo Worklog Proposal Các bài blogs đã dịch Các events đã tham gia Workshop Tự đánh giá Chia sẻ, đóng góp ý kiến "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/3-blogstranslated/3.1-blog1/","title":"Blog 1","tags":[],"description":"","content":"AWS Transfer Family SFTP connectors hiện nay đã hỗ trợ khả năng kết nối dựa trên VPC Nhiều tổ chức phụ thuộc vào Secure File Transfer Protocol (SFTP) như một tiêu chuẩn trong ngành để trao đổi các dữ liệu kinh doanh quan trọng. Trước đây, việc kết nối an toàn đến các máy chủ SFTP riêng thường đòi hỏi phải tự xây dựng hạ tầng, viết các đoạn script thủ công, hoặc mở các endpoint ra internet công cộng.\nHiện nay, AWS Transfer Family SFTP connectors đã hỗ trợ kết nối tới các máy chủ SFTP từ xa thông qua môi trường Amazon Virtual Private Cloud (Amazon VPC). Bạn có thể truyền tệp giữa Amazon Simple Storage Service (Amazon S3) và các máy chủ SFTP riêng tư hoặc công khai, đồng thời áp dụng các biện pháp kiểm soát bảo mật và cấu hình mạng đã được xác định sẵn trong VPC của bạn. Tính năng này giúp bạn tích hợp các nguồn dữ liệu từ môi trường on-premises, máy chủ riêng do đối tác lưu trữ, hoặc các endpoint hướng ra internet, trong khi vẫn duy trì sự đơn giản trong vận hành nhờ sử dụng một dịch vụ Amazon Web Services (AWS) được quản lý hoàn toàn.\nCác khả năng mới với SFTP connectors Dưới đây là các cải tiến chính:\nKết nối tới các máy chủ SFTP riêng tư – Các SFTP connector giờ đây có thể truy cập đến các endpoint chỉ khả dụng trong kết nối AWS VPC của bạn. Điều này bao gồm các máy chủ được lưu trữ trong VPC của bạn hoặc VPC được chia sẻ, các hệ thống on-premises được kết nối qua AWS Direct Connect, và các máy chủ do đối tác lưu trữ được kết nối thông qua đường hầm VPN. Bảo mật và tuân thủ – Tất cả các quá trình truyền tệp đều được định tuyến thông qua các biện pháp kiểm soát bảo mật đã được áp dụng trong VPC của bạn, chẳng hạn như AWS Network Firewall hoặc hệ thống kiểm tra tập trung lưu lượng vào và ra. Các máy chủ SFTP riêng tư vẫn được giữ riêng tư và không cần phải mở ra internet. Bạn cũng có thể sử dụng địa chỉ Elastic IP tĩnh hoặc mang địa chỉ IP của riêng bạn (BYOIP) để đáp ứng các yêu cầu trong danh sách cho phép của đối tác. Hiệu năng và sự đơn giản – Bằng cách sử dụng các tài nguyên mạng của riêng bạn như NAT gateway, AWS Direct Connect hoặc kết nối VPN, các connector có thể tận dụng băng thông cao hơn cho việc truyền tệp quy mô lớn. Bạn có thể cấu hình các connector trong vài phút thông qua AWS Management Console, AWS Command Line Interface (AWS CLI) hoặc AWS SDKs mà không cần xây dựng các script tùy chỉnh hay sử dụng công cụ của bên thứ ba. Cách hoạt động của các kết nối SFTP dựa trên VPC Các SFTP connector sử dụng các tài nguyên Amazon VPC Lattice để thiết lập kết nối bảo mật thông qua VPC của bạn. Các cấu trúc chính bao gồm cấu hình tài nguyên và cổng tài nguyên. Cấu hình tài nguyên đại diện cho máy chủ SFTP đích, mà bạn chỉ định bằng địa chỉ IP riêng tư hoặc tên miền DNS công khai. Cổng tài nguyên cung cấp quyền truy cập cho SFTP connector tới các cấu hình này, cho phép việc truyền tệp đi qua VPC của bạn và các biện pháp kiểm soát bảo mật của nó.\nSơ đồ kiến trúc sau minh họa cách luồng dữ liệu di chuyển giữa Amazon S3 và các máy chủ SFTP từ xa. Như được thể hiện trong kiến trúc, lưu lượng di chuyển từ Amazon S3 thông qua SFTP connector vào VPC của bạn. Cổng tài nguyên là điểm vào xử lý các kết nối đến từ connector tới các tài nguyên trong VPC của bạn. Lưu lượng đi ra được định tuyến thông qua đường ra mà bạn đã cấu hình, sử dụng Amazon VPC NAT gateway với Elastic IP cho các máy chủ công khai hoặc AWS Direct Connect và kết nối VPN cho các máy chủ riêng tư. Bạn có thể sử dụng các địa chỉ IP hiện có từ dải CIDR của VPC, giúp đơn giản hóa danh sách cho phép của máy chủ đối tác. Tường lửa tập trung trong VPC thực thi các chính sách bảo mật, và NAT gateway do khách hàng sở hữu cung cấp băng thông cao hơn cho các truyền tải quy mô lớn.\nKhi nào nên sử dụng tính năng này Với khả năng này, các nhà phát triển và quản trị viên CNTT có thể đơn giản hóa quy trình làm việc trong khi vẫn đáp ứng các yêu cầu về bảo mật và tuân thủ trong nhiều tình huống khác nhau:\nMôi trường lai – Truyền tệp giữa Amazon S3 và các máy chủ SFTP on-premises bằng cách sử dụng AWS Direct Connect hoặc AWS Site-to-Site VPN, mà không cần mở các endpoint ra internet. Tích hợp với đối tác – Kết nối với máy chủ SFTP của đối tác kinh doanh chỉ khả dụng thông qua đường hầm VPN riêng hoặc VPC được chia sẻ. Cách này giúp tránh việc phải xây dựng script tùy chỉnh hoặc quản lý công cụ của bên thứ ba, giảm bớt sự phức tạp trong vận hành. Các ngành được quản lý – Định tuyến việc truyền tệp thông qua tường lửa tập trung và các điểm kiểm tra trong VPC để tuân thủ các yêu cầu bảo mật trong ngành tài chính, chính phủ hoặc y tế. Truyền tải thông lượng cao – Sử dụng cấu hình mạng riêng của bạn như NAT gateway, AWS Direct Connect hoặc kết nối VPN với Elastic IP hoặc BYOIP để xử lý các truyền tải quy mô lớn, băng thông cao, đồng thời vẫn giữ nguyên địa chỉ IP đã nằm trong danh sách cho phép của đối tác. Giải pháp truyền tệp thống nhất – Chuẩn hóa việc sử dụng Transfer Family cho cả kết nối SFTP nội bộ và bên ngoài, giúp giảm sự phân mảnh giữa các công cụ truyền tệp. Bắt đầu xây dựng với SFTP connectors Để bắt đầu truyền tệp với các SFTP connector thông qua môi trường VPC của tôi, tôi thực hiện các bước sau:\nTrước tiên, tôi cấu hình các tài nguyên VPC Lattice của mình. Trong Amazon VPC console, dưới mục PrivateLink and Lattice ở ngăn điều hướng, tôi chọn Resource gateways, chọn Create resource gateway để tạo một cổng hoạt động như điểm vào (ingress point) trong VPC của tôi.\nTiếp theo, dưới PrivateLink and Lattice ở ngăn điều hướng, tôi chọn Resource configuration và chọn Create resource configuration để tạo cấu hình tài nguyên cho máy chủ SFTP mục tiêu của mình. Chỉ định địa chỉ IP riêng hoặc tên miền DNS công khai, và cổng (thường là 22).\nSau đó, tôi cấu hình quyền AWS Identity and Access Management (IAM). Tôi đảm bảo rằng vai trò IAM được sử dụng để tạo connector có các quyền transfer:* và các quyền VPC Lattice ( vpc-lattice:CreateServiceNetworkResourceAssociation, vpc-lattice:GetResourceConfiguration, vpc-lattice:AssociateViaAWSService). Tôi cập nhật chính sách tin cậy trên vai trò IAM để chỉ định transfer.amazonaws.com là principal được tin cậy. Điều này cho phép AWS Transfer Family đảm nhận vai trò này khi tạo và quản lý các SFTP connector của tôi.\nTiếp theo, tôi tạo một SFTP connector thông qua AWS Transfer Family console. Tôi chọn SFTP Connectors rồi chọn Create SFTP connector.\nTrong phần Connector configuration, tôi chọn VPC Lattice làm loại egress, sau đó cung cấp Amazon Resource Name (ARN) của Resource Configuration, Access role, và thông tin xác thực của Connector. Tùy chọn, có thể bao gồm khóa máy chủ đáng tin cậy để tăng cường bảo mật, hoặc ghi đè cổng mặc định nếu máy chủ SFTP của tôi sử dụng một cổng không tiêu chuẩn.\nTiếp theo, tôi kiểm tra kết nối. Trên menu Actions, tôi chọn Test connection để xác nhận rằng connector có thể kết nối đến máy chủ SFTP mục tiêu.\nCuối cùng, sau khi trạng thái của connector là ACTIVE, tôi có thể bắt đầu các thao tác tệp với máy chủ SFTP từ xa của mình thông qua mã bằng cách gọi các API của Transfer Family như StartDirectoryListing, StartFileTransfer, StartRemoteDelete, hoặc StartRemoteMove. Tất cả lưu lượng đều được định tuyến thông qua VPC của tôi bằng cách sử dụng các tài nguyên đã cấu hình như NAT gateway, AWS Direct Connect, hoặc kết nối VPN, cùng với địa chỉ IP và các biện pháp kiểm soát bảo mật của tôi.\nĐể biết đầy đủ các tùy chọn và quy trình nâng cao, hãy tham khảo AWS Transfer Family document.\nHiện đã có sẵn Các SFTP connector với kết nối dựa trên VPC hiện đã có sẵn tại 21 AWS Regions. Hãy kiểm tra AWS Services by Region để biết các vùng AWS được hỗ trợ mới nhất. Giờ đây, bạn có thể kết nối an toàn các AWS Transfer Family SFTP connector tới các máy chủ riêng tư, on-premises hoặc máy chủ hướng internet, bằng cách sử dụng các tài nguyên VPC của riêng bạn như NAT gateway, Elastic IP, và network firewall.\n— Betty\n"},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/3-blogstranslated/3.2-blog2/","title":"Blog 2","tags":[],"description":"","content":"Tổng hợp hàng tuần của AWS: Amazon Quick Suite, Amazon EC2, Amazon EKS và nhiều hơn nữa (ngày 13 tháng 10 năm 2025) Tuần này tôi đã tham dự buổi gặp mặt đầu tiên AWS AI in Practice của AWS User Group UK. Phát triển phần mềm có hỗ trợ AI và các agent là trọng tâm của buổi tối hôm đó! Tuần tới tôi sẽ đến Ý để tham dự Codemotion (Milan) và một buổi gặp mặt AWS User Group (Rome). Các buổi chia sẻ của tôi tại đó sẽ nói về các AI agent và kỹ thuật ngữ cảnh. Tôi cũng rất háo hức được trải nghiệm Amazon Quick Suite mới — bộ công cụ mang khả năng nghiên cứu, phân tích kinh doanh và tự động hóa dựa trên AI vào một không gian làm việc duy nhất.\nCác ra mắt trong tuần trước Dưới đây là những tính năng ra mắt đã thu hút sự chú ý của tôi trong tuần này:\nAmazon Quick Suite – Một đồng đội tự động mới giúp trả lời nhanh các câu hỏi của bạn trong công việc và chuyển những hiểu biết đó thành hành động cho bạn. Đọc thêm trong bài đăng ra mắt của Esra. Amazon EC2 – Các phiên bản M8a chạy bằng bộ xử lý AMD EPYC thế hệ thứ 5 (tên mã Turin) và các phiên bản C8i và C8i-flex chạy bằng bộ xử lý Intel Xeon 6 tùy chỉnh hiện đã có sẵn. Amazon EKS – EKS và EKS Distro hiện đã hỗ trợ Kubernetes phiên bản 1.34 với nhiều cải tiến. AWS IAM Identity Center – Các khóa AWS Key Management Service hiện có thể được sử dụng để mã hóa dữ liệu danh tính được lưu trữ trong các instance IAM Identity Center của tổ chức. Amazon VPC Lattice – Giờ đây bạn có thể cấu hình số lượng địa chỉ IPv4 được gán cho elastic network interfaces (ENIs) của resource gateway. Các địa chỉ IPv4 này được dùng cho dịch địa chỉ mạng và xác định số lượng kết nối IPv4 đồng thời tối đa đến một tài nguyên. Amazon Q Developer – Amazon Q Developer có thể giúp bạn lấy thông tin về giá, khả năng và thuộc tính của các sản phẩm AWS, giúp bạn dễ dàng chọn đúng tài nguyên và ước tính chi phí khối lượng công việc bằng ngôn ngữ tự nhiên. Thông tin chi tiết có trong bài viết trên blog. Amazon RDS for Db2 – Giờ đây bạn có thể thực hiện sao lưu cơ sở dữ liệu ở cấp độ gốc, cung cấp tính linh hoạt cao hơn trong quản lý và di chuyển cơ sở dữ liệu. AWS Service Quotas – Nhận thông báo về việc sử dụng hạn mức với tự động quản lý hạn mức. Có thể cấu hình kênh thông báo ưa thích như email, SMS, hoặc Slack. Thông báo cũng có sẵn trong AWS Health, và bạn có thể đăng ký các sự kiện AWS CloudTrail liên quan cho quy trình tự động hóa. Amazon Connect – Giờ đây bạn có thể làm giàu dữ liệu hồ sơ một cách lập trình với các API hồ sơ mới để liên kết các hồ sơ liên quan, thêm các mục tùy chỉnh liên quan, và tìm kiếm trên chúng. Bạn cũng có thể tùy chỉnh cách tính mức dịch vụ theo nhu cầu cụ thể. Các khả năng mới vừa được giới thiệu bao gồm sao chép và chỉnh sửa hàng loạt cấu hình lịch trình của agent và thông báo về việc tuân thủ lịch trình của agent. AWS Client VPN – Giờ đây hỗ trợ MacOS Tahoe. Cập nhật bổ sung Dưới đây là một số dự án, bài viết blog và tin tức khác mà tôi thấy thú vị:\nServerless ICYMI Q3 2025 – Bản tóm tắt hàng quý về các tin tức serverless, trong trường hợp bạn đã bỏ lỡ. Best practices for migrating from Apache Airflow 2.x to Apache Airflow 3.x on Amazon MWAA – Hướng dẫn giúp bạn tận dụng các lợi ích của phiên bản mới. Building self-managed RAG applications with Amazon EKS and Amazon S3 Vectors – Kiến trúc tham chiếu để xây dựng và triển khai ứng dụng RAG tự quản lý bằng các công cụ mã nguồn mở như Ray, Hugging Face và LangChain. BBVA: Building a multi-region, multi-country global Data and ML Platform at scale – Chuỗi bài viết gồm sáu phần mô tả hành trình chuyển đổi toàn bộ hạ tầng phân tích dữ liệu của BBVA, với một trong những dự án di chuyển lên đám mây lớn và phức tạp nhất trong ngành ngân hàng. Customizing text content moderation with Amazon Nova – Tinh chỉnh Amazon Nova cho các tác vụ kiểm duyệt nội dung văn bản phù hợp với yêu cầu của bạn, bằng cách sử dụng dữ liệu huấn luyện theo lĩnh vực và hướng dẫn kiểm duyệt riêng của tổ chức. Sự kiện AWS sắp tới Hãy kiểm tra lịch của bạn để đăng ký tham gia các sự kiện sắp diễn ra này:\nAWS AI Agent Global Hackathon – Cơ hội để bạn khám phá sâu ngăn xếp AI sinh (generative AI stack) mạnh mẽ của AWS và tạo ra điều gì đó thật ấn tượng. Từ ngày 8 tháng 9 đến 20 tháng 10, bạn có thể tạo AI agents bằng bộ dịch vụ AI của AWS, cạnh tranh cho giải thưởng hơn 45.000 USD cùng cơ hội tiếp cận thị trường độc quyền. AWS Gen AI Lofts – Bạn có thể tìm hiểu về các sản phẩm và dịch vụ AI của AWS thông qua các buổi học độc quyền, gặp gỡ các chuyên gia hàng đầu trong ngành và kết nối với nhà đầu tư cùng đồng nghiệp. Đăng ký tại thành phố gần bạn: Paris (ngày 7–21 tháng 10), London (ngày 13–21 tháng 10), và Tel Aviv (ngày 11–19 tháng 11). AWS Community Days – Tham gia các hội nghị do cộng đồng dẫn dắt, với các buổi thảo luận kỹ thuật, workshop và phòng lab thực hành do những người dùng AWS chuyên nghiệp và các nhà lãnh đạo trong ngành trình bày: Budapest (ngày 16 tháng 10). Tham gia AWS Builder Center để học hỏi, xây dựng và kết nối với các nhà phát triển trong cộng đồng AWS. Tại đây, bạn có thể duyệt qua các sự kiện trực tiếp sắp tới, sự kiện dành cho lập trình viên, và sự kiện dành cho startup.\nĐó là tất cả cho tuần này. Hãy quay lại vào thứ Hai tới để xem bản tổng hợp hàng tuần mới! — Danilo\n"},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/3-blogstranslated/3.3-blog3/","title":"Blog 3","tags":[],"description":"","content":"Giới thiệu Amazon Quick Suite: người đồng hành thông minh hỗ trợ bạn trả lời câu hỏi và thực hiện hành động Hôm nay, chúng tôi thông báo ra mắt Amazon Quick Suite, một đồng nghiệp tác nhân mới có thể nhanh chóng trả lời các câu hỏi của bạn tại nơi làm việc và biến những thông tin chi tiết đó thành hành động cho bạn. Thay vì phải chuyển đổi giữa nhiều ứng dụng để thu thập dữ liệu, tìm các tín hiệu và xu hướng quan trọng, cũng như hoàn thành các tác vụ thủ công, Quick Suite mang khả năng nghiên cứu, trí tuệ kinh doanh và tự động hóa được hỗ trợ bởi AI vào trong một không gian làm việc duy nhất. Giờ đây, bạn có thể phân tích dữ liệu thông qua các truy vấn ngôn ngữ tự nhiên, tìm thông tin quan trọng trên các nguồn doanh nghiệp và bên ngoài chỉ trong vài phút, và tự động hóa các quy trình từ những tác vụ đơn giản đến các quy trình phức tạp giữa nhiều phòng ban.\nDưới đây là cái nhìn tổng quan về Quick Suite.\nNgười dùng doanh nghiệp thường cần thu thập dữ liệu từ nhiều ứng dụng khác nhau — lấy thông tin khách hàng, kiểm tra các chỉ số hiệu suất, xem xét thông tin sản phẩm nội bộ và thực hiện nghiên cứu đối thủ cạnh tranh. Quy trình rời rạc này thường đòi hỏi phải tham khảo ý kiến của các nhóm chuyên môn để phân tích các tập dữ liệu phức tạp, và trong một số trường hợp phải lặp lại thường xuyên, làm giảm hiệu quả và dẫn đến những thông tin chưa đầy đủ cho việc ra quyết định.\nQuick Suite giúp bạn vượt qua những thách thức này bằng cách kết hợp các đồng nghiệp tác nhân cho nghiên cứu, trí tuệ kinh doanh và tự động hóa vào một không gian làm việc kỹ thuật số thống nhất cho công việc hàng ngày của bạn.\nCác khả năng tích hợp giúp nâng cao năng suất Quick Suite bao gồm các khả năng tích hợp sau:\nNghiên cứu – Quick Research tăng tốc quá trình nghiên cứu phức tạp bằng cách kết hợp kiến thức doanh nghiệp, dữ liệu cao cấp từ bên thứ ba và dữ liệu từ internet để mang lại thông tin chuyên sâu toàn diện hơn. Trí tuệ kinh doanh – Quick Sight cung cấp khả năng trí tuệ kinh doanh được hỗ trợ bởi AI, chuyển đổi dữ liệu thành thông tin có thể hành động thông qua các truy vấn ngôn ngữ tự nhiên và trực quan tương tác, giúp mọi người đưa ra quyết định nhanh hơn và đạt được kết quả kinh doanh tốt hơn. Tự động hóa – Quick Flows và Quick Automate giúp người dùng và các nhóm kỹ thuật tự động hóa mọi quy trình kinh doanh từ các tác vụ đơn giản, lặp lại đến các quy trình phức tạp giữa nhiều phòng ban, cho phép thực hiện nhanh hơn và giảm công việc thủ công trên toàn tổ chức. Hãy cùng tìm hiểu một số khả năng chính này.\nQuick Index: Nền tảng tri thức thống nhất của bạn Quick Index tạo ra một kho lưu trữ an toàn, có thể tìm kiếm, hợp nhất tài liệu, tệp và dữ liệu ứng dụng để cung cấp thông tin và phản hồi được hỗ trợ bởi AI trên toàn tổ chức của bạn.\nLà một thành phần nền tảng của Quick Suite, Quick Index hoạt động ở chế độ nền để tập hợp tất cả dữ liệu của bạn — từ cơ sở dữ liệu và kho dữ liệu đến tài liệu và email. Điều này tạo ra một cơ sở tri thức thông minh duy nhất, giúp phản hồi của AI chính xác hơn và giảm thời gian tìm kiếm thông tin.Quick Index tự động lập chỉ mục và chuẩn bị bất kỳ tệp được tải lên hoặc dữ liệu phi cấu trúc nào bạn thêm vào Quick Suite, cho phép tìm kiếm, sắp xếp và truy cập dữ liệu hiệu quả. Ví dụ, khi bạn tìm kiếm bản cập nhật của một dự án cụ thể, Quick Index ngay lập tức trả về kết quả từ các tài liệu đã tải lên, ghi chú cuộc họp, tệp dự án và tài liệu tham khảo — tất cả chỉ trong một lần tìm kiếm thống nhất thay vì phải kiểm tra nhiều kho lưu trữ và hệ thống tệp khác nhau.\nĐể tìm hiểu thêm, hãy truy cập trang tổng quan của Quick Index.\nQuick Research: Từ thách thức kinh doanh phức tạp đến thông tin chuyên sâu ở cấp độ chuyên gia Quick Research là một tác nhân mạnh mẽ thực hiện nghiên cứu toàn diện trên dữ liệu doanh nghiệp của bạn và các nguồn bên ngoài để cung cấp thông tin chuyên sâu có ngữ cảnh và có thể hành động chỉ trong vài phút hoặc vài giờ — những công việc mà trước đây có thể mất nhiều thời gian hơn.\nQuick Research phân tích có hệ thống các câu hỏi phức tạp thành các kế hoạch nghiên cứu có tổ chức. Bắt đầu với một lời nhắc đơn giản, nó tự động tạo ra các khung nghiên cứu chi tiết phác thảo cách tiếp cận và các nguồn dữ liệu cần thiết cho việc phân tích toàn diện.\nSau khi Quick Research tạo kế hoạch, bạn có thể dễ dàng tinh chỉnh nó thông qua các cuộc trò chuyện bằng ngôn ngữ tự nhiên. Khi bạn hài lòng với kế hoạch, nó sẽ hoạt động ở chế độ nền để thu thập thông tin từ nhiều nguồn, sử dụng lập luận nâng cao để xác thực phát hiện và cung cấp phân tích kỹ lưỡng kèm trích dẫn.\nQuick Research tích hợp với dữ liệu doanh nghiệp của bạn được kết nối với Quick Suite, nền tảng tri thức thống nhất kết nối với bảng điều khiển, tài liệu, cơ sở dữ liệu và các nguồn bên ngoài, bao gồm Amazon S3, Snowflake, Google Drive, và Microsoft SharePoint. Quick Research liên kết các thông tin chi tiết quan trọng với các nguồn gốc ban đầu và hiển thị rõ ràng các bước lập luận, giúp bạn xác minh độ chính xác, hiểu logic đằng sau các khuyến nghị và trình bày phát hiện một cách tự tin. Bạn có thể truy ngược các phát hiện về nguồn gốc ban đầu và xác thực kết luận thông qua các trích dẫn nguồn. Điều này khiến nó trở nên lý tưởng cho các chủ đề phức tạp cần phân tích chuyên sâu.\nĐể tìm hiểu thêm, hãy truy cập trang tổng quan của Quick Research.\nQuick Sight: Trí tuệ kinh doanh được hỗ trợ bởi AI Quick Sight cung cấp khả năng trí tuệ kinh doanh được hỗ trợ bởi AI, chuyển đổi dữ liệu thành thông tin chi tiết có thể hành động thông qua các truy vấn ngôn ngữ tự nhiên và trực quan tương tác.\nBạn có thể tạo bảng điều khiển và bản tóm tắt điều hành bằng cách sử dụng các lời nhắc hội thoại, giúp giảm thời gian phát triển bảng điều khiển đồng thời làm cho phân tích nâng cao trở nên dễ tiếp cận mà không cần kỹ năng chuyên môn.\nQuick Sight giúp bạn đặt câu hỏi về dữ liệu của mình bằng ngôn ngữ tự nhiên và nhận ngay các biểu đồ trực quan, bản tóm tắt điều hành và thông tin chi tiết. Tích hợp AI sinh này cung cấp cho bạn câu trả lời từ bảng điều khiển và tập dữ liệu của mình mà không cần chuyên môn kỹ thuật.\nBằng cách sử dụng khả năng mô phỏng kịch bản, bạn có thể thực hiện phân tích \u0026ldquo;what-if\u0026rdquo; bằng ngôn ngữ tự nhiên với hướng dẫn từng bước, khám phá các kịch bản kinh doanh phức tạp và tìm câu trả lời nhanh hơn trước đây.\nNgoài ra, bạn có thể phản hồi các thông tin chi tiết bằng các hành động chỉ với một cú nhấp chuột như tạo phiếu yêu cầu, gửi cảnh báo, cập nhật bản ghi hoặc kích hoạt quy trình tự động trực tiếp từ bảng điều khiển của mình mà không cần chuyển đổi ứng dụng.\nĐể tìm hiểu thêm, hãy truy cập trang tổng quan Quick Sight.\nQuick Flows: Tự động hóa cho mọi người Với Quick Flows, bất kỳ người dùng nào cũng có thể tự động hóa các tác vụ lặp đi lặp lại bằng cách mô tả quy trình làm việc của họ bằng ngôn ngữ tự nhiên mà không cần bất kỳ kiến thức kỹ thuật nào. Quick Flows truy xuất thông tin từ các nguồn nội bộ và bên ngoài, thực hiện hành động trong các ứng dụng kinh doanh, tạo nội dung và xử lý các yêu cầu cụ thể của quy trình.\nBắt đầu với các yêu cầu kinh doanh đơn giản, nó tạo ra một luồng nhiều bước bao gồm các bước nhập để thu thập thông tin, các nhóm lập luận cho xử lý được hỗ trợ bởi AI, và các bước đầu ra để tạo và trình bày kết quả.\nSau khi luồng được cấu hình, bạn có thể chia sẻ nó chỉ với một cú nhấp chuột cho đồng nghiệp và các nhóm khác. Để thực thi luồng, người dùng có thể mở nó từ thư viện hoặc gọi từ trò chuyện, cung cấp các đầu vào cần thiết, sau đó trò chuyện với tác nhân để tinh chỉnh đầu ra và tùy chỉnh kết quả thêm nữa.\nĐể tìm hiểu thêm, hãy truy cập trang tổng quan Quick Flows.\nQuick Automate: Tự động hóa quy trình ở quy mô doanh nghiệp Quick Automate giúp các nhóm kỹ thuật xây dựng và triển khai các tự động hóa tinh vi cho các quy trình phức tạp, nhiều bước trải dài qua các phòng ban, hệ thống và tích hợp bên thứ ba. Bằng cách sử dụng xử lý ngôn ngữ tự nhiên được hỗ trợ bởi AI, Quick Automate chuyển đổi các quy trình kinh doanh phức tạp thành các quy trình làm việc đa tác nhân có thể được tạo ra chỉ bằng cách mô tả những gì bạn muốn tự động hóa hoặc tải lên tài liệu quy trình.\nTrong khi Quick Flows xử lý các quy trình làm việc đơn giản, Quick Automate được thiết kế cho các quy trình kinh doanh toàn diện và phức tạp như quy trình giới thiệu khách hàng mới, tự động hóa mua sắm hoặc các thủ tục tuân thủ có liên quan đến nhiều bước phê duyệt, tích hợp hệ thống và phối hợp giữa các phòng ban. Quick Automate cung cấp các khả năng điều phối nâng cao với các tính năng giám sát, gỡ lỗi, quản lý phiên bản và triển khai toàn diện.\nQuick Automate sau đó tạo ra một kế hoạch tự động hóa toàn diện với các bước và hành động chi tiết. Bạn sẽ thấy một tác nhân giao diện người dùng hiểu các hướng dẫn bằng ngôn ngữ tự nhiên để tự động điều hướng trang web, điền biểu mẫu, trích xuất dữ liệu và tạo ra đầu ra có cấu trúc cho các bước tự động hóa tiếp theo.\nNgoài ra, bạn có thể định nghĩa một tác nhân tùy chỉnh, hoàn chỉnh với hướng dẫn, kiến thức và công cụ, để hoàn thành các nhiệm vụ cụ thể của quy trình bằng trải nghiệm xây dựng trực quan – không cần mã hóa.\nQuick Automate bao gồm các tính năng cấp doanh nghiệp như quản lý vai trò người dùng và khả năng “human-in-the-loop” (con người trong quy trình) cho phép định tuyến các tác vụ cụ thể đến người dùng hoặc nhóm để xem xét và phê duyệt trước khi tiếp tục quy trình làm việc. Dịch vụ cung cấp khả năng quan sát toàn diện với giám sát theo thời gian thực, theo dõi tỷ lệ thành công và nhật ký kiểm toán để đảm bảo tuân thủ và quản trị.\nĐể tìm hiểu thêm, hãy truy cập trang tổng quan Quick Automate.\nCác khả năng nền tảng bổ sung Quick Suite bao gồm các khả năng nền tảng khác mang đến tổ chức dữ liệu liền mạch và tương tác AI theo ngữ cảnh trong toàn doanh nghiệp của bạn.\nSpaces – Spaces cung cấp một cách đơn giản để mọi người dùng doanh nghiệp có thể thêm ngữ cảnh riêng của họ bằng cách tải tệp lên hoặc kết nối với các tập dữ liệu và kho lưu trữ cụ thể cho công việc hoặc chức năng của họ. Ví dụ, bạn có thể tạo một space cho việc lập kế hoạch hàng quý bao gồm bảng tính ngân sách, báo cáo nghiên cứu thị trường và tài liệu hoạch định chiến lược. Hoặc bạn có thể thiết lập một space cho việc ra mắt sản phẩm kết nối với hệ thống quản lý dự án và cơ sở dữ liệu phản hồi khách hàng. Spaces có thể mở rộng từ mục đích cá nhân đến triển khai toàn doanh nghiệp trong khi vẫn duy trì quyền truy cập và tích hợp liền mạch với các khả năng của Quick Suite.\nChat agents – Quick Suite bao gồm các tác nhân thông tin chi tiết mà bạn có thể sử dụng để tương tác với dữ liệu và quy trình làm việc của mình thông qua ngôn ngữ tự nhiên. Quick Suite có một tác nhân tích hợp sẵn để trả lời các câu hỏi trên toàn bộ dữ liệu của bạn và các tác nhân trò chuyện tùy chỉnh mà bạn có thể cấu hình với chuyên môn cụ thể và ngữ cảnh kinh doanh. Các tác nhân trò chuyện tùy chỉnh có thể được điều chỉnh cho các phòng ban hoặc trường hợp sử dụng cụ thể — chẳng hạn như một tác nhân bán hàng được kết nối với dữ liệu danh mục sản phẩm và thông tin giá cả được lưu trữ trong một space, hoặc một tác nhân tuân thủ được cấu hình với các yêu cầu quy định và hành động để yêu cầu phê duyệt.\nNhững điều bổ sung cần biết Nếu bạn là khách hàng Amazon QuickSight hiện tại – Khách hàng Amazon QuickSight sẽ được nâng cấp lên Quick Suite, một không gian làm việc kỹ thuật số hợp nhất bao gồm tất cả các khả năng business intelligence hiện có của bạn (nay được gọi là “Quick Sight”) cùng với các khả năng agentic AI mới. Đây là sự thay đổi về giao diện và tính năng — khả năng kết nối dữ liệu, quyền truy cập người dùng, nội dung, kiểm soát bảo mật, quyền hạn và cài đặt quyền riêng tư của bạn vẫn giữ nguyên hoàn toàn. Không có dữ liệu nào bị di chuyển, chuyển đổi hoặc thay đổi.\nQuick Suite cung cấp mô hình định giá dựa trên đăng ký theo người dùng, với các khoản phí bổ sung dựa trên mức tiêu thụ cho Quick Index và các tính năng tùy chọn khác. Bạn có thể xem chi tiết hơn trên trang định giá Quick Suite.\nHiện đã có sẵn Amazon Quick Suite cung cấp cho bạn một bộ các đồng nghiệp tác nhân giúp bạn có được câu trả lời bạn cần bằng cách sử dụng tất cả dữ liệu của mình và nhanh chóng chuyển từ câu trả lời sang hành động để bạn có thể tập trung vào các hoạt động có giá trị cao hơn, thúc đẩy kết quả kinh doanh và khách hàng tốt hơn.\nTruy cập trang bắt đầu để bắt đầu sử dụng Amazon Quick Suite ngay hôm nay.\nXây dựng vui vẻ\n— Esra and Donnie\n"},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/4-eventparticipated/4.1-event1/","title":"Event 1","tags":[],"description":"","content":"Báo cáo tổng kết: “AWS First Cloud Journey Workforce OJT Fall 2025 Kick-off” Mục tiêu sự kiện Khởi động chương trình AWS First Cloud Journey Workforce OJT Fall 2025 Giúp sinh viên tiếp cận môi trường làm việc chuẩn quốc tế Chia sẻ các thực tiễn tốt nhất về Cloud, DevOps, AI/ML, Security, Data \u0026amp; Analytics Kết nối sinh viên với chuyên gia AWS, cựu sinh viên và các doanh nghiệp đối tác Diễn giả Nguyễn Trần Phước Bảo – Trưởng phòng Quan hệ Doanh nghiệp, Đại học FPT Nguyễn Gia Hưng – Head of Solutions Architect, AWS Vietnam Đỗ Huy Thắng – DevOps Lead, VNG Danh Hoàng Hiếu Nghị – GenAI Engineer, Renova Bùi Hồ Linh Nhi – AI Engineer, SoftwareOne Phạm Nguyễn Hải Anh – Cloud Engineer, G-Asia Pacific Nguyễn Đồng Thanh Hiệp – Principal Cloud Engineer, G-Asia Pacific Điểm nhấn chính Ý nghĩa của buổi Kick-off OJT Đánh dấu sự khởi đầu chính thức của chương trình OJT Fall 2025 tại AWS Bitexco Financial Tower Mang đến cho sinh viên cơ hội học hỏi, thực hành và phát triển trong môi trường chuyên nghiệp Chia sẻ từ chuyên gia Nguyễn Gia Hưng: Giới thiệu tổng quan về OJT tại AWS và đưa ra nhiều lời khuyên nghề nghiệp quý báu Đỗ Huy Thắng: Bài nói chuyện truyền cảm hứng về DevOps, nhấn mạnh tiềm năng phát triển tại Việt Nam và quốc tế Các cựu sinh viên: Chia sẻ trải nghiệm thực tế, tiếp thêm động lực để sinh viên tự tin bước vào kỳ OJT Thông tin chương trình Khởi động từ 2021, đã đồng hành cùng hơn 2.000 sinh viên trên toàn quốc Hơn 150 học viên hiện đang làm việc tại các công ty công nghệ hàng đầu trong và ngoài nước Sứ mệnh: Xây dựng thế hệ AWS Builders chất lượng cao cho Việt Nam Kết nối sinh viên với AWS Study Group (47.000+ thành viên) và các doanh nghiệp đối tác Bài học rút ra Lợi ích cho sinh viên Trải nghiệm thực tế về Cloud, DevOps, AI/ML, Security, Data \u0026amp; Analytics Học hỏi phong cách làm việc chuyên nghiệp theo chuẩn quốc tế Mở rộng mạng lưới với chuyên gia AWS, cựu sinh viên và doanh nghiệp Phát triển sự nghiệp Tiếp cận case study thực tế và các thực tiễn tốt nhất trong ngành Cơ hội gia nhập các công ty công nghệ hàng đầu sau khi tốt nghiệp Khuyến khích tư duy growth mindset và học tập liên tục Ứng dụng vào công việc Thực hành kỹ năng Cloud qua các dự án OJT tại AWS Khám phá DevOps như một hướng đi nghề nghiệp toàn cầu Tận dụng kinh nghiệm từ cựu sinh viên để chuẩn bị cho môi trường làm việc thực tế Tham gia AWS Study Group để học hỏi và kết nối lâu dài Trải nghiệm sự kiện Tham dự AWS First Cloud Journey Workforce OJT Fall 2025 Kick-off mang lại nhiều cảm hứng cho sinh viên. Các trải nghiệm nổi bật:\nHọc hỏi từ chuyên gia Nhận được lời khuyên thực tiễn từ kiến trúc sư AWS và lãnh đạo ngành Hiểu rõ hơn về DevOps và cơ hội nghề nghiệp rộng mở Trải nghiệm thực tế Nhận thức rõ tầm quan trọng của kỹ năng mềm bên cạnh chuyên môn Học cách thích nghi với môi trường làm việc chuẩn quốc tế Mạng lưới kết nối Giao lưu trực tiếp với cựu sinh viên chia sẻ trải nghiệm OJT chân thực Xây dựng mối quan hệ với chuyên gia AWS và doanh nghiệp đối tác Bài học rút ra OJT không chỉ là đào tạo kỹ thuật mà còn là phát triển bản thân Sự hợp tác giữa trường và doanh nghiệp mở ra con đường sự nghiệp vững chắc Với tư duy đúng đắn, sinh viên có thể đạt được thành công ý nghĩa trong ngành công nghệ Tổng thể, buổi Kick-off không chỉ mang lại kiến thức kỹ thuật mà còn truyền cảm hứng, giúp sinh viên Đại học FPT tự tin bắt đầu hành trình OJT với khát vọng và sự chuẩn bị vững chắc.\n"},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/5-workshop/5.1-workshop-overview/","title":"Giới thiệu","tags":[],"description":"","content":"1. Ứng dụng \u0026ldquo;AI Career Coach\u0026rdquo; là gì? AI Career Coach là một nền tảng hỗ trợ người tìm việc làm, tận dụng sức mạnh của Generative AI (AI tạo sinh) để laà nhanh các tác vụ tốn thời gian nhất trong quy trình ứng tuyển.\nDưới đây là 4 module tính năng chính mà chúng ta sẽ xây dựng:\nA. Dashboard (Bảng điều khiển) Nơi người dùng có cái nhìn tổng quan về ngành nghề của mình\nB. AI Resume Builder (Trình tạo CV thông minh) Trình soạn thảo Markdown tích hợp AI. Người dùng nhập thông tin thô, AI sẽ giúp viết lại (rephrase) các câu mô tả kinh nghiệm làm việc sao cho chuyên nghiệp và chuẩn ATS (Applicant Tracking System).\nC. Cover Letter Generator (Tạo thư xin việc) Người dùng chỉ cần cung cấp: \u0026ldquo;Vị trí ứng tuyển\u0026rdquo;, \u0026ldquo;Tên công ty\u0026rdquo; và \u0026ldquo;Mô tả công việc (JD)\u0026rdquo;. Hệ thống sẽ gọi Claude 3 để viết một lá thư xin việc thuyết phục, cá nhân hóa theo JD đó.\nD. Mock Interview (Phỏng vấn thử) Tính năng thú vị nhất. Hệ thống sẽ sinh ra các câu hỏi trắc nghiệm dựa trên ngành nghề của người dùng. Sau khi người dùng trả lời, hệ thống sẽ chấm điểm và đưa ra lời khuyên cải thiện.\n2. Kiến trúc Hệ thống (System Architecture) Đây là phần \u0026ldquo;xương sống\u0026rdquo; của workshop. Chúng ta sẽ áp dụng kiến trúc Serverless hoàn toàn trên AWS.\nHãy nhìn vào sơ đồ luồng dữ liệu dưới đây:\nPhân tích luồng đi (Data Flow): Frontend Hosting: Mã nguồn React (đã build) được lưu trữ trên Amazon S3 và phân phối toàn cầu qua Amazon CloudFront để đảm bảo tốc độ tải trang nhanh nhất. Authentication: Người dùng đăng nhập thông qua Amazon Cognito. Frontend sẽ nhận được JWT Token để xác thực các request gửi lên Server. API Routing: Amazon API Gateway đóng vai trò là cửa ngõ, nhận HTTP Request từ Frontend, kiểm tra Token (Authorizer) và điều hướng đến đúng Lambda Function xử lý. Backend Logic (Compute): Chúng ta sử dụng 5 hàm AWS Lambda viết bằng Java 17 (Spring Cloud Function). Mỗi hàm đảm nhiệm một nghiệp vụ riêng biệt (Microservices pattern). Database: Dữ liệu được lưu trữ trong Amazon DynamoDB với thiết kế Single Table Design (dùng chung 1 bảng cho User, Resume, Interview,\u0026hellip;), tối ưu cho hiệu năng đọc/ghi cực nhanh. AI Integration: Các Lambda Function cần tính năng thông minh sẽ gọi sang Amazon Bedrock để tương tác với mô hình Claude 3 Haiku. 3. Tại sao chọn Tech Stack này? Tại sao chúng ta lại kết hợp Java Spring Boot với Serverless?\nJava \u0026amp; Spring Cloud Function: Java là ngôn ngữ doanh nghiệp phổ biến. Spring Cloud Function giúp các lập trình viên Java dễ dàng chuyển đổi code Spring Boot quen thuộc sang môi trường Serverless mà không cần học lại từ đầu. AWS Lambda \u0026amp; SnapStart: Trước đây Java bị chê là khởi động chậm (Cold Start). Với tính năng Lambda SnapStart, code Java của chúng ta sẽ khởi động cực nhanh, gần như tức thì. DynamoDB Single Table: Đây là kỹ thuật thiết kế DB nâng cao, giúp giảm chi phí và tăng tốc độ truy vấn bằng cách giảm thiểu việc join dữ liệu (vốn không có trong NoSQL). Bedrock: Thay vì phải quản lý server GPU đắt đỏ để chạy AI, Bedrock cung cấp API để gọi các model hàng đầu (như Claude, Llama) theo dạng Serverless (dùng bao nhiêu trả bấy nhiêu). 4. Cấu trúc Source Code Dự án này được tổ chức theo mô hình Monorepo (chứa cả Frontend và Backend trong cùng một kho chứa) để tiện quản lý cho workshop.\nbackend/: Chứa mã nguồn Java Spring Boot. frontend/: Chứa mã nguồn React Vite. template.yaml: File định nghĩa hạ tầng (Infrastructure as Code) của AWS SAM. "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/1-worklog/","title":"Nhật ký công việc","tags":[],"description":"","content":"Thông thường và cũng là tiêu chuẩn, một worklog được thực hiện trong khoảng 3 tháng (trong suốt thời gian thực tập) với nội dung các tuần như sau:\nTuần 1: Làm quen với AWS và các dịch vụ cơ bản trong AWS\nTuần 2: Nghiên cứu và thực hành triển khai các dịch vụ hạ tầng cốt lõi của AWS, bao gồm thiết kế mạng VPC, quản lý máy chủ EC2 và thiết lập kết nối Site-to-Site VPN\nTuần 3: Thực hành cấu hình mạng VPN nâng cao và quản lý EC2 chuyên sâu, đồng thời triển khai ứng dụng thực tế trên đa nền tảng và áp dụng chính sách IAM để bảo mật tài nguyên\nTuần 4: Làm chủ các dịch vụ lưu trữ và phân phối nội dung (S3, CloudFront), quản lý cơ sở dữ liệu quan hệ (RDS), đồng thời thực hành trên môi trường Cloud9 và triển khai ứng dụng nhanh với Amazon Lightsail\nTuần 5: Xây dựng hệ thống có khả năng tự động mở rộng và cân bằng tải (Auto Scaling, ELB), triển khai ứng dụng web kết nối RDS, đồng thời thiết lập giám sát chuyên sâu qua CloudWatch và quản lý định tuyến nâng cao với Route 53\nTuần 6: Tối ưu hóa vận hành và chi phí thông qua việc triển khai WordPress tự động mở rộng, ứng dụng Lambda để quản lý tài nguyên, giám sát hệ thống với Grafana và thực hành quản trị nâng cao bằng Tag, IAM và Systems Manager\nTuần 7: Quản lý kết nối an toàn qua Systems Manager, tự động hóa hạ tầng với CloudFormation nâng cao và thiết lập hệ thống danh tính tập trung (IAM Identity Center) cho toàn bộ tổ chức AWS\nTuần 8: Bảo mật và quản trị hệ thống thông qua việc quản lý danh tính nâng cao (IAM Identity Center, Permission Boundary), triển khai các lớp bảo vệ ứng dụng (Security Hub, WAF), đồng thời thiết lập cơ chế mã hóa, giám sát log và sao lưu tự động (KMS, CloudTrail, Athena, AWS Backup)\nTuần 9: Kết nối mạng đa VPC (Peering, Transit Gateway), triển khai ứng dụng Container trên ECS, xây dựng quy trình CI/CD tự động hóa toàn diện (AWS Code Suite, GitLab/GitHub) và thiết lập giải pháp lưu trữ Hybrid Cloud\nTuần 10: Hiểu Amazon DynamoDB từ các mô hình thiết kế nâng cao đến tích hợp Serverless và AI, song song với việc thực hành tối ưu hóa chi phí hệ thống và triển khai tự động ứng dụng TravelBuddy trên Elastic Beanstalk\nTuần 11: Tập trung thiết kế kiến trúc hệ thống Serverless, mô hình dữ liệu DynamoDB và giao diện người dùng, đồng thời thiết lập môi trường phát triển và hạ tầng AWS SAM cơ bản.\nTuần 12: Phát triển và triển khai Backend hoàn chỉnh với AWS Lambda (Java), tích hợp trí tuệ nhân tạo Amazon Bedrock để xử lý nội dung và hoàn thiện tương tác với cơ sở dữ liệu.\nTuần 13: Xây dựng hoàn thiện Frontend React, tích hợp xác thực và API Backend, sau đó đóng gói và triển khai toàn bộ hệ thống lên môi trường Internet để sẵn sàng demo.\n"},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/5-workshop/5.4-backend-development/5.4.1-user-functions/","title":"User Functions","tags":[],"description":"","content":"Trong bài này, chúng ta sẽ xây dựng module đầu tiên: Quản lý Hồ sơ Người dùng (User Profile).\nChúng ta sẽ đi theo quy trình chuẩn của Spring Boot:\nModel: Định nghĩa cấu trúc dữ liệu. Repository: Tương tác với DynamoDB. Service: Xử lý nghiệp vụ. Function: Tiếp nhận request từ API Gateway. 1. Model (Entity Layer) Đầu tiên, chúng ta cần ánh xạ đối tượng Java với bảng trong DynamoDB.\nChúng ta sử dụng các Annotation của AWS SDK v2 Enhanced Client.\n@Data @DynamoDbBean @NoArgsConstructor @AllArgsConstructor public class UserEntity { private String pk; // Format: USER#\u0026lt;cognito_sub\u0026gt; private String sk; // Format: METADATA // Core fields private String email; private String name; private String imageUrl; private String industry; // Link tới IndustryInsight (Lưu dạng chuỗi text) // Profile fields private String bio; private Integer experience; private List\u0026lt;String\u0026gt; skills; // DynamoDB hỗ trợ List\u0026lt;String\u0026gt; tự động // Timestamps (Lưu dạng ISO String cho dễ đọc: \u0026#34;2025-11-30T10:00:00Z\u0026#34;) private String createdAt; private String updatedAt; @DynamoDbPartitionKey @DynamoDbAttribute(\u0026#34;PK\u0026#34;) public String getPk() { return pk; } @DynamoDbSortKey @DynamoDbAttribute(\u0026#34;SK\u0026#34;) public String getSk() { return sk; } } Chiến lược khóa:\nPK: USER#{userId} (Gom nhóm dữ liệu theo User). SK: METADATA (Định danh đây là thông tin profile). 2. Repository (Data Access Layer) Lớp này chịu trách nhiệm \u0026ldquo;nói chuyện\u0026rdquo; với DynamoDB.\nKế thừa từ lớp cha AbstractDynamoRepository\n@Repository public class UserRepository extends AbstractDynamoRepository\u0026lt;UserEntity\u0026gt; { public UserRepository(DynamoDbEnhancedClient client) { // Truyền Class type để Abstract Repository biết map vào object nào super(client, UserEntity.class); } } 3. Service (Business Logic Layer) Đây là nơi chứa logic nghiệp vụ.\n@Service public class UserService { private static final Logger logger = LoggerFactory.getLogger(UserService.class); // Định nghĩa các hằng số Key Pattern để tránh Hardcode rải rác private static final String USER_PK_PREFIX = \u0026#34;USER#\u0026#34;; private static final String METADATA_SK = \u0026#34;METADATA\u0026#34;; private final UserRepository userRepository; // Constructor Injection public UserService(UserRepository userRepository) { this.userRepository = userRepository; } /** * Lấy thông tin User Profile */ public UserEntity getUserProfile(String userId) { // 1. Validator: Kiểm tra đầu vào validateUserId(userId); // 2. Tạo Key chuẩn Single Table Design String pk = USER_PK_PREFIX + userId; logger.debug(\u0026#34;Fetching profile for user: {}\u0026#34;, userId); // 3. Gọi Repository (Đã có sẵn hàm findById) return userRepository.findById(pk, METADATA_SK); } /** * Cập nhật (hoặc tạo mới) User Profile */ public UserEntity updateUserProfile(String userId, String email, UpdateUserRequest request) { // 1. Validator validateUserId(userId); if (request == null) { throw new IllegalArgumentException(\u0026#34;Update request cannot be null\u0026#34;); } logger.info(\u0026#34;Processing profile update for user: {}\u0026#34;, userId); // 2. Lấy user cũ để kiểm tra tồn tại UserEntity user = getUserProfile(userId); // 3. Logic: Create if not exists (Upsert) if (user == null) { logger.info(\u0026#34;User not found via ID {}, creating new profile...\u0026#34;, userId); if (email == null || email.isEmpty()) { logger.warn(\u0026#34;Creating new user but Email is missing!\u0026#34;); } user = new UserEntity(); user.setPk(USER_PK_PREFIX + userId); user.setSk(METADATA_SK); user.setCreatedAt(Instant.now().toString()); user.setEmail(email); // Chỉ set email khi tạo mới } // 4. Mapping dữ liệu từ DTO sang Entity (Chỉ update nếu có dữ liệu) boolean isUpdated = false; if (hasValue(request.getIndustry())) { user.setIndustry(request.getIndustry()); isUpdated = true; } if (hasValue(request.getBio())) { user.setBio(request.getBio()); isUpdated = true; } if (request.getExperience() != null) { user.setExperience(request.getExperience()); isUpdated = true; } if (request.getSkills() != null \u0026amp;\u0026amp; !request.getSkills().isEmpty()) { user.setSkills(request.getSkills()); isUpdated = true; } // 5. Lưu xuống DB user.setUpdatedAt(Instant.now().toString()); // Dùng hàm save của Repository (nó sẽ log debug bên trong) userRepository.save(user); logger.info(\u0026#34;Profile updated successfully for user: {}\u0026#34;, userId); return user; } // Thêm hàm này vào UserService.java public Map\u0026lt;String, Boolean\u0026gt; checkOnboardingStatus(String userId) { // 1. Validator input if (userId == null || userId.trim().isEmpty()) { logger.error(\u0026#34;CheckOnboardingStatus failed: UserId is null/empty\u0026#34;); throw new IllegalArgumentException(\u0026#34;User ID required\u0026#34;); } // 2. Tạo Key chuẩn String pk = \u0026#34;USER#\u0026#34; + userId; String sk = \u0026#34;METADATA\u0026#34;; logger.info(\u0026#34;Checking onboarding status for User: {}\u0026#34;, userId); // 3. Gọi Repo lấy User UserEntity user = userRepository.findById(pk, sk); // 4. Logic kiểm tra (Giống hệt logic if(!user) throw Error trong JS của bạn) if (user == null) { logger.warn(\u0026#34;User not found in DB: {}\u0026#34;, userId); throw new RuntimeException(\u0026#34;User not found\u0026#34;); } // 5. Logic xác định isOnboarded (Có industry = đã onboard) boolean isOnboarded = user.getIndustry() != null \u0026amp;\u0026amp; !user.getIndustry().trim().isEmpty(); logger.info(\u0026#34;User {} onboarding status: {}\u0026#34;, userId, isOnboarded); return Map.of(\u0026#34;isOnboarded\u0026#34;, isOnboarded); } // --- Helper Methods --- private void validateUserId(String userId) { if (userId == null || userId.trim().isEmpty()) { logger.error(\u0026#34;Validation failed: UserId is null or empty\u0026#34;); throw new IllegalArgumentException(\u0026#34;UserId cannot be null or empty\u0026#34;); } } private boolean hasValue(String value) { return value != null \u0026amp;\u0026amp; !value.trim().isEmpty(); } } 4. Function (Controller Layer) Cuối cùng, chúng ta viết Lambda Handler để nhận HTTP Request từ API Gateway, trích xuất thông tin và gọi Service.\n@Configuration public class UserFunctions { private static final Logger logger = LoggerFactory.getLogger(UserFunctions.class); private final UserService userService; private final ObjectMapper objectMapper; public UserFunctions(UserService userService) { this.userService = userService; this.objectMapper = new ObjectMapper(); this.objectMapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY); this.objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); } //Hàm tổng (ROUTER FUNCTION) để điều phối @Bean public Function\u0026lt;Map\u0026lt;String, Object\u0026gt;, Map\u0026lt;String, Object\u0026gt;\u0026gt; profileHandler() { return event -\u0026gt; { try { // 1. Lấy thông tin cơ bản String httpMethod = extractHttpMethod(event); String path = extractPath(event); // \u0026lt;--- Hàm mới để lấy path logger.info(\u0026#34;Routing Request -\u0026gt; Path: {}, Method: {}\u0026#34;, path, httpMethod); Map\u0026lt;String, String\u0026gt; headers = normalizeHeaders(event); String userId = extractUserIdOrThrow(headers); String email = extractEmail(headers); // 2. ROUTING LOGIC (Bộ điều phối) // TH1: Check Onboarding Status if (path.endsWith(\u0026#34;/onboarding\u0026#34;) \u0026amp;\u0026amp; \u0026#34;GET\u0026#34;.equalsIgnoreCase(httpMethod)) { return handleGetOnboardingStatus(userId); } // TH2: Get Profile if (path.endsWith(\u0026#34;/profile\u0026#34;) \u0026amp;\u0026amp; \u0026#34;GET\u0026#34;.equalsIgnoreCase(httpMethod)) { return handleGetProfile(userId); } // TH3: Update Profile if (path.endsWith(\u0026#34;/profile\u0026#34;) \u0026amp;\u0026amp; \u0026#34;POST\u0026#34;.equalsIgnoreCase(httpMethod)) { return handleUpdateProfile(userId, email, event); } return buildResponse(404, Map.of(\u0026#34;error\u0026#34;, \u0026#34;Route not found: \u0026#34; + path)); } catch (SecurityException e) { return buildResponse(401, Map.of(\u0026#34;error\u0026#34;, e.getMessage())); } catch (IllegalArgumentException e) { // Bắt lỗi user not found từ service return buildResponse(400, Map.of(\u0026#34;error\u0026#34;, e.getMessage())); } catch (Exception e) { logger.error(\u0026#34;System Error\u0026#34;, e); return buildResponse(500, Map.of(\u0026#34;error\u0026#34;, e.getMessage())); } }; } // Các hàm nghiệp vụ private Map\u0026lt;String, Object\u0026gt; handleGetProfile(String userId) { logger.info(\u0026#34;Executing GET logic for User: {}\u0026#34;, userId); UserEntity user = userService.getUserProfile(userId); if (user == null) { return buildResponse(404, Map.of(\u0026#34;error\u0026#34;, \u0026#34;Profile not found\u0026#34;)); } return buildResponse(200, user); } private Map\u0026lt;String, Object\u0026gt; handleUpdateProfile(String userId, String email, Map\u0026lt;String, Object\u0026gt; event) throws Exception { logger.info(\u0026#34;Executing POST logic for User: {}\u0026#34;, userId); String bodyString = extractBodyContent(event); if (bodyString == null || bodyString.trim().isEmpty()) { return buildResponse(400, Map.of(\u0026#34;error\u0026#34;, \u0026#34;Request body is empty\u0026#34;)); } logger.debug(\u0026#34;Request Body: {}\u0026#34;, bodyString); UpdateUserRequest request = objectMapper.readValue(bodyString, UpdateUserRequest.class); UserEntity updatedUser = userService.updateUserProfile(userId, email, request); return buildResponse(200, updatedUser); } private Map\u0026lt;String, Object\u0026gt; handleGetOnboardingStatus(String userId) { try { Map\u0026lt;String, Boolean\u0026gt; result = userService.checkOnboardingStatus(userId); return buildResponse(200, result); } catch (RuntimeException e) { // Nếu lỗi là \u0026#34;User not found\u0026#34;, trả về 404 cho đúng chuẩn REST if (\u0026#34;User not found\u0026#34;.equals(e.getMessage())) { return buildResponse(404, Map.of(\u0026#34;error\u0026#34;, \u0026#34;User not found\u0026#34;)); } throw e; // Ném tiếp để handler chung xử lý 500 } } // --- CÁC HÀM TIỆN ÍCH (HELPERS) --- private String extractHttpMethod(Map\u0026lt;String, Object\u0026gt; event) { // Trong API Gateway V2, method nằm ở: requestContext -\u0026gt; http -\u0026gt; method try { Map\u0026lt;String, Object\u0026gt; requestContext = (Map\u0026lt;String, Object\u0026gt;) event.get(\u0026#34;requestContext\u0026#34;); if (requestContext != null) { Map\u0026lt;String, Object\u0026gt; http = (Map\u0026lt;String, Object\u0026gt;) requestContext.get(\u0026#34;http\u0026#34;); if (http != null \u0026amp;\u0026amp; http.get(\u0026#34;method\u0026#34;) != null) { return http.get(\u0026#34;method\u0026#34;).toString(); } } // Fallback cho một số trường hợp test local hoặc format khác if (event.get(\u0026#34;httpMethod\u0026#34;) != null) { return event.get(\u0026#34;httpMethod\u0026#34;).toString(); } } catch (Exception e) { logger.warn(\u0026#34;Could not extract HTTP method from event\u0026#34;, e); } return \u0026#34;UNKNOWN\u0026#34;; } private String extractPath(Map\u0026lt;String, Object\u0026gt; event) { if (event.get(\u0026#34;rawPath\u0026#34;) != null) { return event.get(\u0026#34;rawPath\u0026#34;).toString(); } // Fallback nếu event cấu trúc khác return \u0026#34;/unknown\u0026#34;; } // ========================================================================= // HELPER METHODS (PRIVATE) // ========================================================================= /** * Chuẩn hóa Header về dạng Map\u0026lt;String, String\u0026gt; và lowercase key để dễ tìm */ private Map\u0026lt;String, String\u0026gt; normalizeHeaders(Map\u0026lt;String, Object\u0026gt; event) { Map\u0026lt;String, String\u0026gt; headers = new HashMap\u0026lt;\u0026gt;(); Object headersObj = event.get(\u0026#34;headers\u0026#34;); logger.info(\u0026#34;DEBUG RAW HEADERS TYPE: {}\u0026#34;, (headersObj != null ? headersObj.getClass().getName() : \u0026#34;null\u0026#34;)); logger.info(\u0026#34;DEBUG RAW HEADERS CONTENT: {}\u0026#34;, headersObj); if (headersObj instanceof Map) { Map\u0026lt;?, ?\u0026gt; rawMap = (Map\u0026lt;?, ?\u0026gt;) headersObj; for (Map.Entry\u0026lt;?, ?\u0026gt; entry : rawMap.entrySet()) { if (entry.getKey() != null \u0026amp;\u0026amp; entry.getValue() != null) { headers.put(entry.getKey().toString().toLowerCase(), entry.getValue().toString()); } } } logger.info(\u0026#34;DEBUG NORMALIZED HEADERS: {}\u0026#34;, headers); return headers; } /** * Trích xuất và giải mã Body từ Event (xử lý cả Base64) */ private String extractBodyContent(Map\u0026lt;String, Object\u0026gt; event) { Object bodyObj = event.get(\u0026#34;body\u0026#34;); if (bodyObj == null) return null; String bodyString; if (bodyObj instanceof String) { bodyString = (String) bodyObj; } else { // Trường hợp Spring đã lỡ parse thành Map try { bodyString = objectMapper.writeValueAsString(bodyObj); } catch (Exception e) { logger.warn(\u0026#34;Failed to convert body object to string\u0026#34;, e); return \u0026#34;{}\u0026#34;; } } // Xử lý Base64 nếu AWS API Gateway bật tính năng này Object isBase64Obj = event.get(\u0026#34;isBase64Encoded\u0026#34;); if (isBase64Obj != null \u0026amp;\u0026amp; Boolean.parseBoolean(isBase64Obj.toString())) { try { bodyString = new String(Base64.getDecoder().decode(bodyString)); } catch (Exception e) { logger.error(\u0026#34;Failed to decode Base64 body\u0026#34;, e); throw new RuntimeException(\u0026#34;Invalid Base64 body\u0026#34;); } } return bodyString; } /** * Tạo Response chuẩn cho API Gateway */ private Map\u0026lt;String, Object\u0026gt; buildResponse(int statusCode, Object body) { Map\u0026lt;String, Object\u0026gt; response = new HashMap\u0026lt;\u0026gt;(); response.put(\u0026#34;statusCode\u0026#34;, statusCode); Map\u0026lt;String, String\u0026gt; headers = new HashMap\u0026lt;\u0026gt;(); headers.put(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;); // CORS Headers (Nếu cần thiết, dù API Gateway thường đã xử lý) headers.put(\u0026#34;Access-Control-Allow-Origin\u0026#34;, \u0026#34;*\u0026#34;); response.put(\u0026#34;headers\u0026#34;, headers); try { String jsonBody = objectMapper.writeValueAsString(body); response.put(\u0026#34;body\u0026#34;, jsonBody); } catch (Exception e) { response.put(\u0026#34;statusCode\u0026#34;, 500); response.put(\u0026#34;body\u0026#34;, \u0026#34;{\\\u0026#34;error\\\u0026#34;: \\\u0026#34;JSON Serialization Error\\\u0026#34;}\u0026#34;); } return response; } // --- SECURITY HELPERS --- private String extractUserIdOrThrow(Map\u0026lt;String, String\u0026gt; headers) { String sub = extractClaim(headers, \u0026#34;sub\u0026#34;); if (sub == null) { throw new SecurityException(\u0026#34;Missing \u0026#39;sub\u0026#39; claim in token or Invalid Token\u0026#34;); } return sub; } private String extractEmail(Map\u0026lt;String, String\u0026gt; headers) { return extractClaim(headers, \u0026#34;email\u0026#34;); } private String extractClaim(Map\u0026lt;String, String\u0026gt; headers, String claimKey) { // Tìm header Authorization (đã được normalize về chữ thường) String authHeader = headers.get(\u0026#34;authorization\u0026#34;); logger.info(\u0026#34;DEBUG AUTH HEADER FOUND: {}\u0026#34;, authHeader); if (authHeader == null || !authHeader.startsWith(\u0026#34;Bearer \u0026#34;)) { logger.warn(\u0026#34;Authorization header missing or invalid format\u0026#34;); // Thay vì trả về test ID, ta trả về null để hàm gọi ném lỗi 401 return null; } try { String token = authHeader.substring(7); String[] parts = token.split(\u0026#34;\\\\.\u0026#34;); if (parts.length \u0026lt; 2) return null; String payloadJson = new String(Base64.getUrlDecoder().decode(parts[1])); JsonNode node = objectMapper.readTree(payloadJson); if (node.has(claimKey)) { return node.get(claimKey).asText(); } } catch (Exception e) { logger.error(\u0026#34;Token decoding failed: {}\u0026#34;, e.getMessage()); } return null; } } "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/1-worklog/1.1-week1/","title":"Worklog Tuần 1","tags":[],"description":"","content":"Mục tiêu tuần 1: Kết nối, làm quen với các thành viên trong First Cloud Journey. Hiểu dịch vụ AWS cơ bản và cách dùng console \u0026amp; CLI. Các công việc cần triển khai trong tuần này: Thứ Công việc Ngày bắt đầu Ngày hoàn thành Nguồn tài liệu 2 - Làm quen với các thành viên FCJ - Đọc và lưu ý các nội quy, quy định tại đơn vị thực tập 08/09/2025 08/09/2025 3 - Tìm hiểu AWS và các loại dịch vụ + Compute + Storage + Networking + Database + \u0026hellip; 09/09/2025 09/09/2025 cloudjourney.awsstudygroup.com và YouTube của AWS Study Group 4 - Tạo AWS Free Tier account - Tìm hiểu AWS Console \u0026amp; AWS CLI - Thực hành: + Tạo AWS account + Cài AWS CLI \u0026amp; cấu hình + Cách sử dụng AWS CLI 10/09/2025 10/09/2025 cloudjourney.awsstudygroup.com và YouTube của AWS Study Group 5 - Quản lý chi phí với AWS Budget - Yêu cầu hỗ trợ từ AWS Support - Quản trị quyền truy cập với AWS Identity and Access Management (IAM) 11/09/2025 11/09/2025 cloudjourney.awsstudygroup.com 6 - Thực hành: + Tạo Cost Budget + Tạo Usage Budget + Tạo RI Budget + Tạo IAM Group và IAM User + Tạo IAM Role và OperatorUser + Chuyển đổi Role cho OperatorUser 12/09/2025 12/09/2025 cloudjourney.awsstudygroup.com và YouTube của AWS Study Group Kết quả đạt được tuần 1: Hiểu AWS là gì và nắm được các nhóm dịch vụ cơ bản:\nCompute Storage Networking Database \u0026hellip; Đã tạo và cấu hình AWS Free Tier account thành công.\nLàm quen với AWS Management Console và biết cách tìm, truy cập, sử dụng dịch vụ từ giao diện web.\nCài đặt và cấu hình AWS CLI trên máy tính, bao gồm:\nThiết lập Access Key và Secret Key Cấu hình Region mặc định Kiểm tra thông tin cấu hình và tài khoản Thiết lập và quản lý chi phí thông qua AWS Budgets:\nCost Budget Usage Budget RI Budget Quản lý quyền truy cập người dùng bằng AWS IAM:\nTạo IAM Group, IAM User, IAM Role Phân quyền và chuyển đổi Role cho OperatorUser "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/2-proposal/","title":"Bản đề xuất","tags":[],"description":"","content":"AI Career Coach 1. Tóm tắt điều hành Nền tảng AI Career Coach được thiết kế dành cho người tìm việc và sinh viên mới ra trường nhằm tối ưu hóa quy trình ứng tuyển và nâng cao cơ hội việc làm. Hệ thống hoạt động như một trợ lý ảo thông minh, hỗ trợ từ việc xây dựng hồ sơ (CV), viết thư xin việc (Cover Letter) đến luyện tập phỏng vấn. Nền tảng tận dụng sức mạnh của AWS Serverless để đảm bảo khả năng mở rộng tự động và Amazon Bedrock (Generative AI) để cá nhân hóa nội dung sâu sắc. Hệ thống đảm bảo bảo mật thông tin cá nhân người dùng thông qua Amazon Cognito.\n2. Tuyên bố vấn đề Vấn đề hiện tại\nNgười tìm việc hiện nay tốn quá nhiều thời gian để chỉnh sửa CV thủ công cho từng vị trí ứng tuyển. Việc viết thư xin việc thường mang tính rập khuôn, thiếu điểm nhấn. Ngoài ra, cung cấp cho ứng viên môi trường để luyện tập kiến thức chuyên môn và phân tích thông tin chi tiết xu hướng về nghề nghiệp bản thân (Industry Insights) một cách nhanh nhất.\nGiải pháp\nNền tảng sử dụng kiến trúc AWS Serverless toàn diện để giải quyết các vấn đề trên:\nAmazon S3 \u0026amp; CloudFront: Lưu trữ và phân phối giao diện web (SPA) với tốc độ cao. Amazon Cognito: Quản lý định danh và xác thực người dùng an toàn. Amazon API Gateway \u0026amp; AWS Lambda (Java Spring Cloud Function): Xử lý logic nghiệp vụ theo kiến trúc Microservices (User, Resume, Cover Letter, Interview). Amazon DynamoDB: Lưu trữ dữ liệu hồ sơ, bài đánh giá và thông tin ngành nghề với độ trễ thấp. Amazon Bedrock: Trái tim của hệ thống, cung cấp khả năng nâng cấp CV, soạn thảo Cover Letter và sinh câu hỏi phỏng vấn theo ngữ cảnh thực tế. Nền tảng tập trung sâu vào tính năng \u0026ldquo;Cá nhân hóa bằng AI\u0026rdquo;, người dùng không chỉ lưu trữ CV mà còn được AI hỗ trợ. Các tính năng chính bao gồm: nâng cấp CV, viết thư xin việc dựa trên JD bằng AI, làm quiz ôn tập kiến thức, báo cáo xu hướng ngành nghề.\nLợi ích và hoàn vốn đầu tư (ROI)\nGiảm nhiều thời gian viết cover letter và chỉnh sửa CV. Tận dụng AWS Free Tier cho Lambda, DynamoDB và Cognito, chi phí chủ yếu đến từ việc gọi API Bedrock. Ước tính chi phí vận hành hàng tháng khoảng 3-5 USD cho nhu cầu sử dụng cá nhân hoặc quy mô nhỏ (dưới 1000 request AI/tháng). Giá trị lớn nhất không nằm ở tiền mặt trực tiếp mà ở việc rút ngắn viết cover letter và chỉnh sửa CV. Không có chi phí phần cứng ban đầu.\n3. Kiến trúc giải pháp Nền tảng áp dụng kiến trúc AWS Serverless hoàn toàn (Full Serverless) để tối ưu hóa khả năng mở rộng và chi phí bảo trì. Giao diện người dùng được phân phối toàn cầu thông qua Amazon CloudFront và S3. Hệ thống backend sử dụng kiến trúc Microservices với AWS Lambda (Java Spring Cloud Function) để xử lý nghiệp vụ và Amazon Bedrock để tích hợp trí tuệ nhân tạo. Dữ liệu hồ sơ và đánh giá được quản lý tập trung bởi Amazon DynamoDB, đảm bảo hiệu năng cao và bảo mật.\nDịch vụ AWS sử dụng\nAmazon CloudFront \u0026amp; S3: Lưu trữ và phân phối giao diện Web với độ trễ thấp. Amazon Cognito: Quản lý định danh, đăng ký/đăng nhập và xác thực người dùng an toàn. Amazon API Gateway: Cổng REST API quản lý traffic và định tuyến yêu cầu đến đúng Lambda Service. AWS Lambda: Xử lý logic nghiệp vụ (5 services: User, Resume, Cover Letter, Interview, Industry) trên môi trường Java Spring. Amazon DynamoDB: Cơ sở dữ liệu NoSQL lưu trữ thông tin người dùng, resume và lịch sử đánh giá (1 bảng). Amazon Bedrock: Cung cấp các mô hình nền tảng (Claude 3 Haiku/Sonnet) để phân tích và tạo nội dung. Thiết kế thành phần\nGiao diện người dùng (Frontend): Ứng dụng Next.js Single Page Application (SPA) tương tác với backend thông qua RESTful API. Quản lý truy cập: Amazon Cognito (User Pool) xác thực người dùng và cấp JWT Token cho các API request. Xử lý trung tâm: AWS Lambda thực thi các hàm Spring Cloud Function, kết nối với Bedrock để xử lý các tác vụ thông minh (tạo quiz, sửa CV). Lớp dữ liệu: DynamoDB được tổ chức theo mô hình \u0026ldquo;một bảng\u0026rdquo; (single-table) để tối ưu hoá việc tổ chức dữ liệu và cho phép truy vấn hiệu quả. Trí tuệ nhân tạo: Amazon Bedrock nhận ngữ cảnh từ Lambda, thực hiện suy luận (Inference) và trả về kết quả tư vấn hoặc nội dung văn bản. 4. Triển khai kỹ thuật Các giai đoạn triển khai Dự án được chia thành 2 giai đoạn lớn, tập trung vào việc thiết kế kiến trúc Serverless tối ưu cho Java và tích hợp Generative AI:\nNghiên cứu, Thiết kế và Đánh giá khả thi: Thiết kế sơ đồ luồng dữ liệu AWS Serverless, xác định chiến lược chia tách Microservices với Spring Cloud Function. Lựa chọn model AI phù hợp (Claude 3 Haiku) dựa trên benchmark về độ chính xác và tốc độ. Sử dụng AWS Pricing Calculator để ước tính chi phí Lambda (thời gian chạy Java), DynamoDB (Read/Write capacity) và quan trọng nhất là chi phí Token của Amazon Bedrock. Thiết lập ngân sách dự kiến (AWS Budget) để đảm bảo dự án nằm trong giới hạn Free Tier hoặc chi phí thấp nhất. (Tháng thứ 2) Phát triển, Tối ưu hóa và Vận hành: Xây dựng các hàm Lambda bằng Java (Spring Boot 3), cấu hình DynamoDB Multi-table, và viết Prompt Engineering cho Bedrock để tối ưu kết quả đầu ra cho CV/Interview. Tích hợp Frontend (Next.js) với API Gateway và Cognito, thực hiện kiểm thử tích hợp (Integration Test) toàn hệ thống trước khi Go-live.(Tháng thứ 3) Yêu cầu kỹ thuật\nBackend Services (Java Serverless): Thành thạo Java 17/21 và Spring Cloud Function để viết code theo mô hình hướng chức năng. Hiểu sâu về cơ chế AWS Lambda SnapStart để tối ưu hóa thời gian khởi động ứng dụng Java (giảm độ trễ từ hàng giây xuống mili-giây). Generative AI \u0026amp; Data: Kỹ năng Prompt Engineering nâng cao để điều khiển model Claude 3 trên Amazon Bedrock trả về định dạng JSON chuẩn xác. Thiết kế schema DynamoDB hiệu quả (Partition Key/Sort Key) cho các truy vấn lịch sử đánh giá và hồ sơ người dùng. Infrastructure \u0026amp; Security: Sử dụng Amazon Cognito để quản lý User Pool và xác thực JWT. Cấu hình Amazon API Gateway để map request và xử lý CORS cho Frontend. Triển khai Frontend (Next.js) lên Amazon S3 và phân phối qua CloudFront. 5. Lộ trình \u0026amp; Mốc triển khai Thực tập (Tháng 1–3): Tháng 1: Học AWS và nâng cấp phần cứng. Tháng 2: Thiết kế và điều chỉnh kiến trúc. Tháng 3: Triển khai, kiểm thử, đưa vào sử dụng. Sau triển khai: Nghiên cứu thêm để mở rộng thêm nhiều chức năng. 6. Ước tính ngân sách Có thể xem chi phí trên AWS Pricing Calculator\nChi phí hạ tầng (Khu vực: Asia Pacific - Singapore)\nAmazon Bedrock: 2.70 USD/tháng (Mô hình AI, xử lý ~1,000 token input/output mỗi request). Amazon CloudFront: 0.85 USD/tháng (Truyền tải dữ liệu ra internet 10 GB). Amazon DynamoDB: 0.28 USD/tháng (Lưu trữ 1 GB, chế độ Standard). AWS Lambda: 0.13 USD/tháng (4,000 request, 512 MB bộ nhớ tạm). Amazon S3: 0.05 USD/tháng (Lưu trữ 1 GB, 4,000 request PUT/GET). Tổng cộng: 4.01 USD/tháng, tương đương 48.12 USD/12 tháng. 7. Đánh giá rủi ro Ma trận rủi ro\nẢo giác AI (Hallucination): Ảnh hưởng Cao, Xác suất Trung bình. (AI đưa ra lời khuyên sai lệch hoặc bịa đặt thông tin trong CV). Chi phí vượt ngân sách: Ảnh hưởng Trung bình, Xác suất Thấp. (Do phí token của Bedrock nếu lượng request tăng đột biến). Độ trễ hệ thống (Cold Start): Ảnh hưởng Trung bình, Xác suất Thấp. (Do đặc thù của Java Lambda function khi khởi động). Chiến lược giảm thiểu\nAI chính xác: Tối ưu hóa Prompt Engineering với ngữ cảnh cụ thể, thiết lập tham số Temperature thấp (0.1 - 0.2) để giảm tính ngẫu nhiên. Thêm cảnh báo miễn trừ trách nhiệm (Disclaimer) cho người dùng. Kiểm soát chi phí: Thiết lập AWS Budgets để cảnh báo khi chi phí đạt 80% ngưỡng cho phép. Hiệu năng: Kích hoạt tính năng AWS Lambda SnapStart để giảm thời gian khởi động Java từ hàng giây xuống mili-giây. Kế hoạch dự phòng\nSự cố dịch vụ AI: Thiết kế hệ thống để \u0026ldquo;fail gracefully\u0026rdquo; (thông báo lỗi thân thiện) hoặc trả về các template mẫu có sẵn nếu Amazon Bedrock bị gián đoạn. Khôi phục dữ liệu: Kích hoạt tính năng Point-in-Time Recovery (PITR) của DynamoDB để khôi phục dữ liệu user trong trường hợp thao tác xóa nhầm hoặc lỗi ứng dụng. 8. Kết quả kỳ vọng Cải tiến kỹ thuật: Tự động hóa 90% quy trình chuẩn bị hồ sơ ứng tuyển (từ sửa CV đến viết thư xin việc), thay thế hoàn toàn việc soạn thảo thủ công tốn thời gian. Hệ thống đạt độ trễ thấp (mili-giây) nhờ tối ưu hóa Java SnapStart, có khả năng chịu tải cao mà không cần can thiệp hạ tầng. Giá trị dài hạn: Xây dựng thành công bộ khung kiến trúc mẫu cho các ứng dụng Java Serverless kết hợp GenAI trên AWS, có thể tái sử dụng cho các dự án doanh nghiệp. Tạo ra môi trường thực tế để thử nghiệm và tinh chỉnh các kỹ thuật Prompt Engineering phức tạp, phục vụ cho hướng phát triển chuyên sâu về AI Engineer.\n"},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/5-workshop/5.2-prerequiste/","title":"Các bước chuẩn bị","tags":[],"description":"","content":"Để xây dựng và triển khai ứng dụng AI Career Coach, chúng ta cần thiết lập một môi trường phát triển mạnh mẽ. Hãy đảm bảo bạn cài đặt đầy đủ các công cụ dưới đây trước khi bước vào phần code.\nℹ️ Lưu ý quan trọng: Dự án này yêu cầu bạn phải có tài khoản AWS (Amazon Web Services). Nếu chưa có, hãy đăng ký một tài khoản tại đây. Tài khoản Free Tier là đủ để thực hiện workshop này.\n1. Cài đặt Runtime (Ngôn ngữ lập trình) A. Java 17 (JDK) Backend của chúng ta sử dụng Spring Boot 3, yêu cầu tối thiểu là Java 17.\nTải xuống: Truy cập Oracle JDK 17 hoặc Amazon Corretto 17. Cài đặt: Chạy file cài đặt theo hệ điều hành của bạn (Windows/Mac/Linux). Kiểm tra: Mở Terminal (hoặc CMD/PowerShell) và gõ lệnh: java -version Kết quả mong đợi: Bạn sẽ thấy phiên bản hiển thị là 17.x.x.\nB. Node.js \u0026amp; npm Frontend React (Vite) cần môi trường Node.js.\nTải xuống: Truy cập Node.js và tải bản LTS (Long Term Support) (ví dụ: v18 hoặc v20). Kiểm tra: Mở Terminal (hoặc CMD/PowerShell) và gõ lệnh: node -v npm -v 2. Cài đặt bộ công cụ AWS Đây là những công cụ giúp chúng ta giao tiếp với AWS Cloud và triển khai ứng dụng Serverless.\nA. AWS CLI (Command Line Interface) Công cụ dòng lệnh chính thức của AWS.\nWindows: Tải file MSI installer tại đây. MacOS: Tải file PKG tại đây. Linux: Xem hướng dẫn chi tiết tại đây. Kiểm tra cài đặt:\naws --version B. AWS SAM CLI (Serverless Application Model) Công cụ giúp xây dựng, test và deploy ứng dụng Serverless (Lambda, DynamoDB\u0026hellip;) dễ dàng hơn.\nHướng dẫn cài đặt: Xem tài liệu chính thức của AWS SAM Kiểm tra cài đặt: sam --version 3. Cấu hình AWS Credentials Sau khi cài AWS CLI, bạn cần kết nối nó với tài khoản AWS của mình thông qua Access Key.\nBước 1: Tạo Access Key\nĐăng nhập vào AWS Console. Tìm dịch vụ IAM -\u0026gt; Chọn Users -\u0026gt; Chọn User của bạn (hoặc tạo mới). Vào tab Security credentials -\u0026gt; Bấm Create access key. Chọn Use case: Command Line Interface (CLI). Tải file .csv chứa Access Key ID và Secret Access Key về máy. Bước 2: Cấu hình trên máy\nMở Terminal và chạy lệnh:\naws configure Nhập lần lượt các thông tin:\nAWS Access Key ID: [Paste Key ID của bạn] AWS Secret Access Key: [Paste Secret Key của bạn] Default region name: ap-southeast-1 (Singapore) (Hoặc region gần bạn nhất) Default output format: json 4. Kích hoạt Model AI (Quan trọng) Dự án sử dụng mô hình Claude 3 Haiku của Anthropic thông qua Amazon Bedrock. Mặc định, quyền truy cập này bị tắt.\nĐăng nhập AWS Console, tìm dịch vụ Amazon Bedrock. Đảm bảo bạn đang ở đúng Region đã cấu hình (ví dụ: Singapore). Ở menu bên trái, chọn Model catalog. Tìm nhà cung cấp Anthropic. ℹ️ Lưu ý: Bạn cần nộp form \u0026ldquo;Use Case Details\u0026rdquo; trước. Điền thông tin là \u0026ldquo;Personal Project\u0026rdquo; cho mục đích học tập\nTick chọn Claude 3 Haiku. Nếu Open in playground có màu cam thì đã sử dụng được. 5. IDE \u0026amp; Extensions (Khuyên dùng) Để code hiệu quả nhất, bạn nên sử dụng Visual Studio Code (VS Code) hoặc IntelliJ IDEA.\nNếu dùng VS Code, hãy cài đặt các Extensions sau:\nExtension Pack for Java: Hỗ trợ code Java/Spring Boot. ES7+ React/Redux/React-Native snippets: Hỗ trợ code React nhanh. AWS Toolkit: Quản lý tài nguyên AWS ngay trong VS Code. YAML: Hỗ trợ highlight cú pháp cho file template.yaml. ✅ Checklist kiểm tra Trước khi sang bài tiếp theo, hãy chắc chắn bạn đã tích đủ các mục sau:\nĐã cài Java 17 (java -version). Đã cài Node.js (node -v). Đã cài AWS SAM CLI (sam --version). Đã chạy aws configure thành công. Đã thấy Open in playground cho Claude 3 Haiku trên AWS Bedrock. "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/5-workshop/5.4-backend-development/5.4.2-industry-functions/","title":"Industry Functions","tags":[],"description":"","content":"Trong bài cuối cùng của phần Backend, chúng ta sẽ xây dựng chức năng Industry Insight (Thông tin thị trường).\nChức năng này giúp người dùng nhập vào một ngành nghề (ví dụ: \u0026ldquo;React Developer\u0026rdquo;) và nhận lại các thông tin như:\nMức lương trung bình. Kỹ năng yêu cầu. Xu hướng tuyển dụng. Chiến lược: Cache-First Gọi AI (Bedrock) tốn phí cho mỗi token. Thông tin thị trường không thay đổi từng giây. Do đó, chúng ta sẽ áp dụng chiến lược:\nNgười dùng hỏi về \u0026ldquo;Java Developer\u0026rdquo;. Kiểm tra DynamoDB xem đã có thông tin này chưa. Nếu CÓ: Trả về ngay lập tức (Nhanh, Rẻ). Nếu KHÔNG: Gọi Bedrock phân tích -\u0026gt; Lưu vào DB -\u0026gt; Trả về (Chậm hơn chút, nhưng chỉ tốn 1 lần). 1. Model (Entity Layer) Định nghĩa cấu trúc dữ liệu để lưu trữ kết quả phân tích thị trường vào DynamoDB.\n@Data @DynamoDbBean public class IndustryInsightEntity { private String pk; // Format: INDUSTRY#\u0026lt;tên_ngành\u0026gt; (Ví dụ: INDUSTRY#tech-software) private String sk; // Format: METADATA // AI Bedrock Generated Data private Float growthRate; private String demandLevel; // \u0026#34;High\u0026#34;, \u0026#34;Medium\u0026#34;, \u0026#34;Low\u0026#34; private String marketOutlook; private List\u0026lt;String\u0026gt; topSkills; private List\u0026lt;String\u0026gt; keyTrends; private List\u0026lt;String\u0026gt; recommendedSkills; // Nested JSON cho lương private List\u0026lt;SalaryRangeItem\u0026gt; salaryRanges; private String lastUpdated; private String nextUpdate; @DynamoDbPartitionKey @DynamoDbAttribute(\u0026#34;PK\u0026#34;) public String getPk() { return pk; } @DynamoDbSortKey @DynamoDbAttribute(\u0026#34;SK\u0026#34;) public String getSk() { return sk; } // Inner Class cho dải lương @Data @DynamoDbBean public static class SalaryRangeItem { private String role; private Float min; private Float max; private Float median; private String location; } } Quy tắc đặt Key:\nPK: INSIGHT#{tên_ngành_viết_thường} (Ví dụ: INSIGHT#java-developer). SK: METADATA. 2. Repository (Data Access Layer) Tương tác với DynamoDB để tìm kiếm và lưu trữ Insight.\nKế thừa từ lớp cha AbstractDynamoRepository\n@Repository public class IndustryInsightRepository extends AbstractDynamoRepository\u0026lt;IndustryInsightEntity\u0026gt; { public IndustryInsightRepository(DynamoDbEnhancedClient client) { super(client, IndustryInsightEntity.class); } /** * Tìm Insight dựa trên tên ngành. * PK: INDUSTRY#\u0026lt;industryName\u0026gt; * SK: METADATA */ public IndustryInsightEntity findByIndustry(String industryName) { if (industryName == null || industryName.trim().isEmpty()) { return null; } // Chuẩn hóa key (ví dụ: lowercase hoặc slugify nếu cần thiết) // Ở đây giả định lưu nguyên văn chuỗi String pk = \u0026#34;INDUSTRY#\u0026#34; + industryName; String sk = \u0026#34;METADATA\u0026#34;; return findById(pk, sk); } } 3. Service (AI Integration Layer) Nơi xử lý logic kết hợp với BedrockService để thực hiện chức năng thống kê bằng AI\n@Service public class IndustryInsightService { private static final Logger logger = LoggerFactory.getLogger(IndustryInsightService.class); private final UserRepository userRepository; private final IndustryInsightRepository insightRepository; private final BedrockService bedrockService; public IndustryInsightService(UserRepository userRepository, IndustryInsightRepository insightRepository, BedrockService bedrockService) { this.userRepository = userRepository; this.insightRepository = insightRepository; this.bedrockService = bedrockService; } public IndustryInsightEntity getIndustryInsights(String userId) { // 1. Validate User ID if (userId == null || userId.isEmpty()) { throw new IllegalArgumentException(\u0026#34;User ID is required\u0026#34;); } // 2. Lấy thông tin User để biết họ làm ngành gì // PK: USER#\u0026lt;id\u0026gt;, SK: METADATA UserEntity user = userRepository.findById(\u0026#34;USER#\u0026#34; + userId, \u0026#34;METADATA\u0026#34;); if (user == null) { logger.error(\u0026#34;User not found: {}\u0026#34;, userId); throw new RuntimeException(\u0026#34;User not found\u0026#34;); } // 3. Kiểm tra xem User đã chọn ngành chưa String industry = user.getIndustry(); if (industry == null || industry.trim().isEmpty()) { logger.warn(\u0026#34;User {} has not selected an industry yet\u0026#34;, userId); // Có thể throw lỗi hoặc trả về null tùy logic frontend throw new RuntimeException(\u0026#34;User has not selected an industry\u0026#34;); } // 4. Tìm Insight trong DB logger.info(\u0026#34;Fetching insights for industry: {}\u0026#34;, industry); IndustryInsightEntity insight = insightRepository.findByIndustry(industry); // 5. Nếu chưa có hoặc (Optional: đã hết hạn cache), gọi AI tạo mới // Ở đây logic gốc là \u0026#34;If no insights exist\u0026#34;, tôi giữ nguyên logic đó. if (insight == null) { logger.info(\u0026#34;Insight not found for \u0026#39;{}\u0026#39;. Generating via Bedrock AI...\u0026#34;, industry); // Gọi AI insight = bedrockService.generateIndustryInsights(industry); // Bổ sung các thông tin quản lý DB insight.setPk(\u0026#34;INDUSTRY#\u0026#34; + industry); insight.setSk(\u0026#34;METADATA\u0026#34;); insight.setLastUpdated(Instant.now().toString()); // Set next update = now + 7 days insight.setNextUpdate(Instant.now().plus(7, ChronoUnit.DAYS).toString()); // Lưu vào DB insightRepository.save(insight); logger.info(\u0026#34;Saved new insights for \u0026#39;{}\u0026#39;\u0026#34;, industry); } else { logger.info(\u0026#34;Found existing insights for \u0026#39;{}\u0026#39; in DB\u0026#34;, industry); } return insight; } } 4. Function (Controller Layer) Hàm Lambda cuối cùng để xây dựng API.\n@Configuration public class IndustryFunctions { private static final Logger logger = LoggerFactory.getLogger(IndustryFunctions.class); private final IndustryInsightService insightService; private final ObjectMapper objectMapper; public IndustryFunctions(IndustryInsightService insightService) { this.insightService = insightService; this.objectMapper = new ObjectMapper(); this.objectMapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY); this.objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); } /** * HÀM TỔNG (DISPATCHER) CHO INDUSTRY * Quản lý tất cả route liên quan đến /industry-insights */ @Bean public Function\u0026lt;Map\u0026lt;String, Object\u0026gt;, Map\u0026lt;String, Object\u0026gt;\u0026gt; industryInsightHandler() { return event -\u0026gt; { try { String path = extractPath(event); String method = extractHttpMethod(event); logger.info(\u0026#34;Industry Handler -\u0026gt; Path: {}, Method: {}\u0026#34;, path, method); // Chuẩn hóa Header \u0026amp; Auth Map\u0026lt;String, String\u0026gt; headers = normalizeHeaders(event); String userId = extractUserIdOrThrow(headers); // --- ROUTING LOGIC --- // Route 1: GET /industry-insights if (path.endsWith(\u0026#34;/industry-insights\u0026#34;) \u0026amp;\u0026amp; \u0026#34;GET\u0026#34;.equalsIgnoreCase(method)) { return handleGetIndustryInsights(userId); } // Route 2 (Ví dụ tương lai): POST /industry-insights/refresh (Force update AI) // if (path.endsWith(\u0026#34;/refresh\u0026#34;) ...) { return handleRefresh(userId); } return buildResponse(404, Map.of(\u0026#34;error\u0026#34;, \u0026#34;Route not found in Industry Function\u0026#34;)); } catch (SecurityException e) { return buildResponse(401, Map.of(\u0026#34;error\u0026#34;, e.getMessage())); } catch (Exception e) { logger.error(\u0026#34;System Error\u0026#34;, e); return buildResponse(500, Map.of(\u0026#34;error\u0026#34;, e.getMessage())); } }; } // --- LOGIC CON --- private Map\u0026lt;String, Object\u0026gt; handleGetIndustryInsights(String userId) { IndustryInsightEntity result = insightService.getIndustryInsights(userId); return buildResponse(200, result); } // --- CÁC HÀM HELPER (Copy từ UserFunctions sang hoặc gom vào 1 file Utils dùng chung) --- // (Để code ngắn gọn ở đây mình ví dụ các hàm quan trọng, bạn copy phần decode token từ UserFunctions sang nhé) private String extractPath(Map\u0026lt;String, Object\u0026gt; event) { return event.get(\u0026#34;rawPath\u0026#34;) != null ? event.get(\u0026#34;rawPath\u0026#34;).toString() : \u0026#34;\u0026#34;; } private String extractHttpMethod(Map\u0026lt;String, Object\u0026gt; event) { Map\u0026lt;String, Object\u0026gt; req = (Map) event.get(\u0026#34;requestContext\u0026#34;); if (req != null) { Map\u0026lt;String, Object\u0026gt; http = (Map) req.get(\u0026#34;http\u0026#34;); if (http != null) return http.get(\u0026#34;method\u0026#34;).toString(); } return \u0026#34;GET\u0026#34;; } private Map\u0026lt;String, String\u0026gt; normalizeHeaders(Map\u0026lt;String, Object\u0026gt; event) { Map\u0026lt;String, String\u0026gt; headers = new HashMap\u0026lt;\u0026gt;(); Object headersObj = event.get(\u0026#34;headers\u0026#34;); if (headersObj instanceof Map) { Map\u0026lt;?, ?\u0026gt; rawMap = (Map\u0026lt;?, ?\u0026gt;) headersObj; for (Map.Entry\u0026lt;?, ?\u0026gt; entry : rawMap.entrySet()) { headers.put(entry.getKey().toString().toLowerCase(), entry.getValue().toString()); } } return headers; } private String extractUserIdOrThrow(Map\u0026lt;String, String\u0026gt; headers) { // ... Logic extract token giống hệt UserFunctions ... // (Lưu ý: Bạn nên tạo class JwtUtils để tái sử dụng đoạn này đỡ phải copy paste) String authHeader = headers.get(\u0026#34;authorization\u0026#34;); if (authHeader != null \u0026amp;\u0026amp; authHeader.startsWith(\u0026#34;Bearer \u0026#34;)) { try { String token = authHeader.substring(7); String[] parts = token.split(\u0026#34;\\\\.\u0026#34;); String payloadJson = new String(Base64.getUrlDecoder().decode(parts[1])); // Nhớ dùng Base64UrlDecoder return new ObjectMapper().readTree(payloadJson).get(\u0026#34;sub\u0026#34;).asText(); } catch (Exception e) { logger.error(\u0026#34;Token error\u0026#34;, e); } } throw new SecurityException(\u0026#34;Invalid Token\u0026#34;); } private Map\u0026lt;String, Object\u0026gt; buildResponse(int statusCode, Object body) { Map\u0026lt;String, Object\u0026gt; response = new HashMap\u0026lt;\u0026gt;(); response.put(\u0026#34;statusCode\u0026#34;, statusCode); Map\u0026lt;String, String\u0026gt; headers = new HashMap\u0026lt;\u0026gt;(); headers.put(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;); response.put(\u0026#34;headers\u0026#34;, headers); try { response.put(\u0026#34;body\u0026#34;, objectMapper.writeValueAsString(body)); } catch (Exception e) { response.put(\u0026#34;statusCode\u0026#34;, 500); response.put(\u0026#34;body\u0026#34;, \u0026#34;{}\u0026#34;); } return response; } } "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/1-worklog/1.2-week2/","title":"Worklog Tuần 2","tags":[],"description":"","content":"Mục tiêu tuần 2: Hiểu và thực hành các dịch vụ hạ tầng cốt lõi của AWS, bao gồm VPC, EC2 và Site-to-Site VPN. Biết cách xây dựng, cấu hình và bảo mật mạng VPC cơ bản. Triển khai và quản lý EC2 Instance trong môi trường Public và Private Subnet. Nắm khái niệm kết nối mạng giữa on-premises và AWS Cloud thông qua Site-to-Site VPN. Các công việc cần triển khai trong tuần này: Thứ Công việc Ngày bắt đầu Ngày hoàn thành Nguồn tài liệu 2 - Tìm hiểu cơ bản về VPC: + Subnets + Route Table + Internet Gateway + NAT Gateway + Security Groups + Network Access Control Lists - Thực hành: Xây dựng môi trường VPC với các thành phần mạng cơ bản (VPC, Subnets, Route Table, Internet Gateway, Security Groups, VPC Flow Logs) và thiết lập cấu trúc mạng an toàn, có khả năng mở rộng. 15/09/2025 15/09/2025 cloudjourney.awsstudygroup.com và YouTube của AWS Study Group 3 - Tìm hiểu cơ bản về EC2: + Khái niệm, tính năng và cách hoạt động của EC2 + Các loại instance (General Purpose, Compute Optimized, Memory Optimized, …) + Khái niệm AMI, EBS, Security Group và Key Pair + Cấu hình mạng, lưu trữ và quyền truy cập cho EC2 Instance + Quy trình khởi tạo, kết nối và quản lý vòng đời instance (Start, Stop, Reboot, Terminate) 16/09/2025 16/09/2025 cloudjourney.awsstudygroup.com 4 - Tìm hiểu về VPC Reachability Analyzer, EC2 Instance Connect Endpoint, AWS Systems Manager Session Manager, CloudWatch Monitoring - Thực hành: Triển khai Amazon EC2 Instances + Tạo EC2 instance trong Public và Private Subnet + Kết nối SSH + Tạo Elastic IP + Tạo NAT Gateway + Cấu hình Route Table cho Private Subnet + Phân tích kết nối với VPC Reachability Analyzer + Triển khai EIC Endpoint 17/09/2025 18/09/2025 cloudjourney.awsstudygroup.com 5 - Tìm hiểu về AWS Site-to-Site VPN: + Virtual Private Gateway (VPG) + Customer Gateway (CGW) 18/09/2025 18/09/2025 cloudjourney.awsstudygroup.com 6 - Thực hành: + Thiết lập VPC cho Site-to-Site VPN + Triển khai EC2 Instance cho Customer Gateway + Tạo Virtual Private Gateway + Tạo Customer Gateway + Thiết lập kết nối VPN giữa VPC và môi trường on-premises + Cấu hình Customer Gateway + Chỉnh AWS VPN Tunnel 19/09/2025 19/09/2025 cloudjourney.awsstudygroup.com Kết quả đạt được tuần 2: Hiểu rõ cấu trúc và nguyên lý hoạt động của VPC trên AWS, bao gồm:\nSubnet, Route Table, Internet Gateway, NAT Gateway, Security Group và Network ACL. Tự xây dựng được mô hình VPC cơ bản có khả năng mở rộng và đảm bảo an toàn truy cập giữa các subnet. Nắm vững kiến thức cơ bản về Amazon EC2, bao gồm: Phân loại instance và lựa chọn AMI phù hợp Cấu hình lưu trữ (EBS), bảo mật (Security Group, Key Pair) và mạng (Elastic IP, Route Table) Quản lý vòng đời instance (khởi tạo, kết nối, dừng, xóa) Thực hành triển khai EC2 Instance trong Public và Private Subnet, kết nối qua SSH và quản lý truy cập bằng Instance Connect Endpoint. Biết sử dụng VPC Reachability Analyzer và CloudWatch để giám sát và phân tích kết nối mạng. Hiểu khái niệm, thành phần và quy trình thiết lập Site-to-Site VPN giữa hệ thống on-premises và AWS Cloud. Tự thực hành tạo kết nối VPN an toàn giữa Customer Gateway và Virtual Private Gateway, giúp mở rộng mạng nội bộ lên đám mây AWS. "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/3-blogstranslated/","title":"Các bài blogs đã dịch","tags":[],"description":"","content":"Dưới đây là các bài blog tôi đã dịch:\nBlog 1 - AWS Transfer Family SFTP connectors hiện nay đã hỗ trợ khả năng kết nối dựa trên VPC Blog này thông báo rằng AWS Transfer Family SFTP connectors hiện đã hỗ trợ kết nối dựa trên VPC, cho phép truyền tệp an toàn giữa Amazon S3 và các máy chủ SFTP riêng hoặc công khai mà không cần mở điểm cuối ra internet. Bằng cách tận dụng các tài nguyên VPC hiện có như NAT gateway, VPN và tường lửa, người dùng có thể tích hợp hệ thống tại chỗ và máy chủ của đối tác trong khi vẫn đảm bảo tuân thủ và hiệu suất. Việc cấu hình được đơn giản hóa qua AWS Console hoặc CLI, giúp dễ dàng quản lý môi trường lai và khối lượng công việc trong ngành có quy định nghiêm ngặt.\nBlog 2 - Tổng hợp hàng tuần của AWS: Amazon Quick Suite, Amazon EC2, Amazon EKS và nhiều hơn nữa (ngày 13 tháng 10 năm 2025) Blog này tổng hợp các cập nhật mới nhất từ AWS tính đến ngày 13 tháng 10 năm 2025, bao gồm việc ra mắt Amazon Quick Suite—một không gian làm việc tích hợp AI cho nghiên cứu và tự động hóa—cùng các phiên bản EC2 mới sử dụng bộ xử lý AMD và Intel. Bài viết cũng đề cập đến việc hỗ trợ Kubernetes 1.34 trong Amazon EKS, cải tiến mã hóa trong IAM Identity Center, và các nâng cấp cho Amazon VPC Lattice, Amazon RDS for Db2 và Amazon Connect. Ngoài ra, blog còn giới thiệu các sự kiện AWS sắp tới như AI Agent Global Hackathon và Gen AI Lofts tại châu Âu.\nBlog 3 - Giới thiệu Amazon Quick Suite: người đồng hành thông minh hỗ trợ bạn trả lời câu hỏi và thực hiện hành động Blog này giới thiệu Amazon Quick Suite, một không gian làm việc số tích hợp trí tuệ nhân tạo, đóng vai trò như một “đồng đội tác vụ” giúp trả lời câu hỏi và tự động hóa công việc. Nền tảng này kết hợp các công cụ nghiên cứu, phân tích dữ liệu và tự động hóa—như Quick Research, Quick Sight, Quick Flows và Quick Automate—trong một giao diện thống nhất. Người dùng có thể truy vấn bằng ngôn ngữ tự nhiên để phân tích dữ liệu, tạo ra các thông tin chuyên sâu và tối ưu hóa quy trình làm việc. Các tính năng như Quick Index và chatbot tùy chỉnh giúp tăng hiệu suất bằng cách tập trung hóa tri thức và tương tác AI theo ngữ cảnh trong toàn doanh nghiệp.\n"},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/5-workshop/5.3-infrastructure-as-code/","title":"Hạ tầng với SAM","tags":[],"description":"","content":"Thay vì phải click chuột thủ công hàng trăm lần trên AWS Console để tạo Database, Lambda, API Gateway\u0026hellip; chúng ta sẽ sử dụng phương pháp Infrastructure as Code (IaC).\nVới AWS SAM (Serverless Application Model), toàn bộ kiến trúc hệ thống được định nghĩa trong duy nhất một file: template.yaml.\n1. Cấu hình Toàn cục (Globals) Để tránh lặp lại code (Don\u0026rsquo;t Repeat Yourself), chúng ta định nghĩa các thông số chung cho tất cả các hàm Lambda trong phần Globals.\nYAML Globals: Function: Timeout: 60 # Tăng lên 60s vì gọi AI Bedrock có thể lâu MemorySize: 2048 # Java cần RAM khá để chạy mượt Runtime: java17 Architectures: [x86_64] Environment: Variables: TABLE_NAME: !Ref CoreTable # ID của model Bedrock (Claude 3 Haiku) BEDROCK_MODEL_ID: \u0026#34;anthropic.claude-3-haiku-20240307-v1:0\u0026#34; Với Java, RAM nhiều hơn đồng nghĩa với CPU mạnh hơn và thời gian khởi động (Cold Start) ngắn hơn. Kết hợp với tính năng SnapStart, ứng dụng sẽ phản hồi tức thì.\n2. Định nghĩa Backend (Lambda Functions) Mỗi tính năng của chúng ta tương ứng với một resource AWS::Serverless::Function\nBạn có thể xem các định nghĩa các lamda trong template.yaml tại link github\nVí dụ với hàm Cover Letter:\nYAML CoverLetterFunction: Type: AWS::Serverless::Function Properties: CodeUri: backend/target/backend-0.0.1-SNAPSHOT-aws.jar Handler: org.springframework.cloud.function.adapter.aws.FunctionInvoker::handleRequest Timeout: 60 # Gọi AI nên cần timeout lâu MemorySize: 2048 SnapStart: ApplyOn: PublishedVersions Policies: - DynamoDBCrudPolicy: TableName: !Ref CoreTable - Statement: - Effect: Allow Action: - bedrock:InvokeModel - bedrock:InvokeModelWithResponseStream # Thêm quyền Marketplace để sửa lỗi AccessDenied - aws-marketplace:ViewSubscriptions - aws-marketplace:Subscribe - aws-marketplace:Unsubscribe Resource: \u0026#34;*\u0026#34; Environment: Variables: TABLE_NAME: !Ref CoreTable BEDROCK_MODEL_ID: \u0026#34;anthropic.claude-3-haiku-20240307-v1:0\u0026#34; # Chạy hàm coverLetterHandler SPRING_CLOUD_FUNCTION_DEFINITION: coverLetterHandler Events: # 1. Generate (POST) GenerateCoverLetter: Type: HttpApi Properties: ApiId: !Ref HttpApi Path: /cover-letters Method: POST Auth: Authorizer: CognitoAuthorizer # 2. List All (GET) ListCoverLetters: Type: HttpApi Properties: ApiId: !Ref HttpApi Path: /cover-letters Method: GET Auth: Authorizer: CognitoAuthorizer # 3. Get One (GET /{id}) GetOneCoverLetter: Type: HttpApi Properties: ApiId: !Ref HttpApi Path: /cover-letters/{id} Method: GET Auth: Authorizer: CognitoAuthorizer # 4. Delete (DELETE /{id}) DeleteCoverLetter: Type: HttpApi Properties: ApiId: !Ref HttpApi Path: /cover-letters/{id} Method: DELETE Auth: Authorizer: CognitoAuthorizer Lưu ý quan trọng nhất đối với các hàm lambda là đoạn code chạy đúng logic nhưng vẫn bị lỗi AccessDenied? Đó là do Lambda mặc định không có quyền làm gì cả. Chúng ta phải cấp quyền cụ thể:\nbedrock:InvokeModel: Cho phép Lambda gửi prompt đến mô hình Claude 3. bedrock:InvokeModelWithResponseStream: Cho phép gọi mô hình theo kiểu streaming (dữ liệu trả về theo luồng — token từng phần). Dùng cho ứng dụng cần nhận output dần dần (streaming responses). aws-marketplace:ViewSubscriptions: Cho phép xem trạng thái đăng ký các sản phẩm trên AWS Marketplace của tài khoản (liệt kê các subscription hiện có). Cần để kiểm tra xem tài khoản đã subscribe model bên thứ ba hay chưa. aws-marketplace:Subscribe:Vì Claude 3 là mô hình của bên thứ 3 (Anthropic), Lambda cần quyền kiểm tra xem tài khoản AWS của bạn đã đăng ký (Subscribe) model này chưa. Thiếu quyền này, Bedrock sẽ từ chối phục vụ. aws-marketplace:Unsubscribe: Cho phép hủy đăng ký (unsubscribe) một sản phẩm trên Marketplace. 3. Định nghĩa Database \u0026amp; Auth DynamoDB (Single Table) Chúng ta khai báo bảng với chế độ thanh toán PAY_PER_REQUEST (Serverless) - dùng bao nhiêu trả bấy nhiêu, không tốn phí duy trì khi không ai dùng.\nYAML CoreTable: Type: AWS::DynamoDB::Table Properties: TableName: AICareerCoachDB BillingMode: PAY_PER_REQUEST AttributeDefinitions: - AttributeName: PK AttributeType: S - AttributeName: SK AttributeType: S - AttributeName: GSI1_PK AttributeType: S - AttributeName: GSI1_SK AttributeType: S KeySchema: - AttributeName: PK KeyType: HASH - AttributeName: SK KeyType: RANGE GlobalSecondaryIndexes: - IndexName: GSI1 KeySchema: - AttributeName: GSI1_PK KeyType: HASH - AttributeName: GSI1_SK KeyType: RANGE Projection: ProjectionType: ALL 4. Cognito User Pool Nơi quản lý người dùng. Chúng ta cấu hình AutoVerifiedAttributes: [email] để tự động gửi email xác thực khi đăng ký.\nYAML UserPool: Type: AWS::Cognito::UserPool Properties: UserPoolName: CareerCoachUsers AutoVerifiedAttributes: [email] UsernameAttributes: [email] Policies: PasswordPolicy: MinimumLength: 8 # Kích hoạt Trigger sau khi đăng ký để lưu vào DynamoDB LambdaConfig: PostConfirmation: !GetAtt PostSignupTriggerFunction.Arn UserPoolClient: Type: AWS::Cognito::UserPoolClient Properties: ClientName: ReactClient UserPoolId: !Ref UserPool GenerateSecret: false # Web App (React) không dùng Secret ExplicitAuthFlows: [ALLOW_USER_SRP_AUTH, ALLOW_REFRESH_TOKEN_AUTH] # Lambda nhỏ (NodeJS) để hứng sự kiện đăng ký và lưu user vào DB # (Dùng Nodejs cho cái này vì nó khởi động cực nhanh và nhẹ) PostSignupTriggerFunction: Type: AWS::Serverless::Function Properties: Runtime: nodejs18.x MemorySize: 128 Timeout: 5 Handler: index.handler InlineCode: | const { DynamoDBClient, PutItemCommand } = require(\u0026#34;@aws-sdk/client-dynamodb\u0026#34;); const client = new DynamoDBClient({}); exports.handler = async (event) =\u0026gt; { if (event.triggerSource === \u0026#34;PostConfirmation_ConfirmSignUp\u0026#34;) { const userId = event.request.userAttributes.sub; const email = event.request.userAttributes.email; const params = { TableName: process.env.TABLE_NAME, Item: { PK: { S: `USER#${userId}` }, SK: { S: \u0026#34;METADATA\u0026#34; }, email: { S: email }, createdAt: { S: new Date().toISOString() } } }; try { await client.send(new PutItemCommand(params)); } catch (err) { console.error(err); } } return event; }; Environment: Variables: TABLE_NAME: !Ref CoreTable Policies: - DynamoDBCrudPolicy: TableName: !Ref CoreTable # Cấp quyền cho Cognito được gọi Lambda Trigger PostSignupTriggerPermission: Type: AWS::Lambda::Permission Properties: Action: lambda:InvokeFunction FunctionName: !Ref PostSignupTriggerFunction Principal: cognito-idp.amazonaws.com SourceArn: !GetAtt UserPool.Arn 5. Frontend Hosting (S3 + CloudFront OAC) Đây là kiến trúc hosting hiện đại và bảo mật nhất cho Static Web hiện nay.\nCác thành phần:\nS3 Bucket: Nơi chứa file index.html, js, css. Chế độ PublicAccessBlock được bật (Chặn truy cập trực tiếp từ internet). CloudFront Distribution: CDN giúp cache nội dung và cung cấp HTTPS. Origin Access Control (OAC): Dùng OAC. Đây là vệ sĩ đứng giữa. Nó ký request từ CloudFront gửi sang S3. Kết quả: Người dùng bắt buộc phải đi qua CloudFront (có HTTPS, có Cache). Nếu cố tình truy cập link S3 trực tiếp sẽ bị chặn (403 Forbidden).\nYAML # Cấu hình bảo mật mới (OAC) CloudFrontOriginAccessControl: Type: AWS::CloudFront::OriginAccessControl Properties: OriginAccessControlConfig: Description: \u0026#34;Access Control for CV Analyzer\u0026#34; Name: !Sub \u0026#34;OAC-${FrontendBucket}\u0026#34; OriginAccessControlOriginType: s3 SigningBehavior: always SigningProtocol: sigv4 YAML FrontendBucket: Type: AWS::S3::Bucket Properties: BucketName: !Sub \u0026#34;career-coach-frontend-${AWS::AccountId}\u0026#34; # Thêm ID tài khoản để chắc chắn không trùng tên PublicAccessBlockConfiguration: BlockPublicAcls: true BlockPublicPolicy: true IgnorePublicAcls: true RestrictPublicBuckets: true FrontendBucketPolicy: Type: AWS::S3::BucketPolicy Properties: Bucket: !Ref FrontendBucket PolicyDocument: Version: \u0026#34;2012-10-17\u0026#34; Statement: - Sid: \u0026#34;AllowCloudFrontServicePrincipal\u0026#34; Effect: Allow Principal: Service: \u0026#34;cloudfront.amazonaws.com\u0026#34; # Dùng Service Principal chuẩn (Luôn tồn tại) Action: \u0026#34;s3:GetObject\u0026#34; Resource: !Sub \u0026#34;${FrontendBucket.Arn}/*\u0026#34; Condition: StringEquals: \u0026#34;AWS:SourceArn\u0026#34;: !Sub \u0026#34;arn:aws:cloudfront::${AWS::AccountId}:distribution/${FrontendDistribution}\u0026#34; FrontendDistribution: Type: AWS::CloudFront::Distribution Properties: DistributionConfig: Enabled: true DefaultRootObject: index.html Origins: - DomainName: !GetAtt FrontendBucket.RegionalDomainName # Lưu ý dùng RegionalDomainName Id: S3Origin OriginAccessControlId: !GetAtt CloudFrontOriginAccessControl.Id # Trỏ vào OAC mới S3OriginConfig: OriginAccessIdentity: \u0026#34;\u0026#34; # Để trống dòng này vì đã dùng OAC DefaultCacheBehavior: TargetOriginId: S3Origin ViewerProtocolPolicy: redirect-to-https AllowedMethods: [GET, HEAD, OPTIONS] CachedMethods: [GET, HEAD, OPTIONS] ForwardedValues: QueryString: false Cookies: Forward: none CustomErrorResponses: - ErrorCode: 403 ResponseCode: 200 ResponsePagePath: /index.html - ErrorCode: 404 ResponseCode: 200 ResponsePagePath: /index.html 6. Outputs (Kết quả đầu ra) Sau khi deploy xong, CloudFormation sẽ trả về các thông số quan trọng để chúng ta cấu hình cho Frontend.\nYAML Outputs: ApiEndpoint: Description: \u0026#34;API URL để dán vào Frontend .env\u0026#34; Value: !Sub \u0026#34;https://${HttpApi}.execute-api.${AWS::Region}.amazonaws.com\u0026#34; CognitoUserPoolId: Description: \u0026#34;User Pool ID\u0026#34; Value: !Ref UserPool CognitoClientId: Description: \u0026#34;App Client ID\u0026#34; Value: !Ref UserPoolClient WebsiteURL: Description: \u0026#34;URL trang web React của bạn (CloudFront)\u0026#34; Value: !GetAtt FrontendDistribution.DomainName S3BucketName: Description: \u0026#34;Tên Bucket để upload code Frontend\u0026#34; Value: !Ref FrontendBucket "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/5-workshop/5.4-backend-development/5.4.3-resume-functions/","title":"Resume Functions","tags":[],"description":"","content":"Trong bài này, chúng ta sẽ xây dựng Resume Function. Đây không chỉ là nơi lưu trữ nội dung CV mà còn là \u0026ldquo;trợ lý viết lách\u0026rdquo; cho người dùng.\nTính năng chính: Lưu trữ (Storage): Lưu toàn bộ nội dung CV dưới dạng Markdown vào DynamoDB. Tại sao là Markdown? Vì nó nhẹ, dễ format và dễ chuyển đổi sang PDF. Nâng cấp (Improvement): Gửi các đoạn mô tả kinh nghiệm thô sơ lên AI (Claude 3) để viết lại chuyên nghiệp hơn. 1. Model (Entity Layer) Định nghĩa cấu trúc lưu trữ CV trong DynamoDB.\n@Data @DynamoDbBean public class ResumeEntity { private String pk; // Format: USER#\u0026lt;cognito_sub\u0026gt; private String sk; // Format: RESUME private String content; // Markdown text private Double atsScore; // Điểm số ATS private String feedback; // Feedback từ Bedrock AI private String createdAt; private String updatedAt; @DynamoDbPartitionKey @DynamoDbAttribute(\u0026#34;PK\u0026#34;) public String getPk() { return pk; } @DynamoDbSortKey @DynamoDbAttribute(\u0026#34;SK\u0026#34;) public String getSk() { return sk; } } Chiến lược khóa:\nPK: USER#{userId} (Gắn liền với user). SK: RESUME (Mỗi user chỉ có 1 bản nháp CV chính trong ngữ cảnh này). 2. Repository (Data Access Layer) Kế thừa từ lớp cha AbstractDynamoRepository.\n@Repository public class ResumeRepository extends AbstractDynamoRepository\u0026lt;ResumeEntity\u0026gt; { public ResumeRepository(DynamoDbEnhancedClient client) { super(client, ResumeEntity.class); } // Tìm Resume theo UserID (Quan hệ 1-1) // PK: USER#\u0026lt;userId\u0026gt;, SK: RESUME public ResumeEntity findByUserId(String userId) { String pk = \u0026#34;USER#\u0026#34; + userId; String sk = \u0026#34;RESUME\u0026#34;; return findById(pk, sk); } } 3. Service Đây là phần thú vị nhất. Hàm improveWithAI sẽ gọi Amazon Bedrock.\nKết hợp với BedrockService để thực hiện chức năng improveWithAI bằng AI\n@Service public class ResumeService { private static final Logger logger = LoggerFactory.getLogger(ResumeService.class); private final ResumeRepository resumeRepository; private final UserRepository userRepository; private final BedrockService bedrockService; public ResumeService(ResumeRepository resumeRepository, UserRepository userRepository, BedrockService bedrockService) { this.resumeRepository = resumeRepository; this.userRepository = userRepository; this.bedrockService = bedrockService; } // 1. Save Resume (Upsert) public ResumeEntity saveResume(String userId, String content) { if (content == null || content.trim().isEmpty()) { throw new IllegalArgumentException(\u0026#34;Resume content cannot be empty\u0026#34;); } // Kiểm tra user có tồn tại không // (Tùy chọn: nếu tin tưởng token thì có thể bỏ qua bước này để tiết kiệm 1 RCU) ResumeEntity resume = resumeRepository.findByUserId(userId); if (resume == null) { logger.info(\u0026#34;Creating new resume for user: {}\u0026#34;, userId); resume = new ResumeEntity(); resume.setPk(\u0026#34;USER#\u0026#34; + userId); resume.setSk(\u0026#34;RESUME\u0026#34;); resume.setCreatedAt(Instant.now().toString()); } else { logger.info(\u0026#34;Updating existing resume for user: {}\u0026#34;, userId); } resume.setContent(content); resume.setUpdatedAt(Instant.now().toString()); resumeRepository.save(resume); return resume; } // 2. Get Resume public ResumeEntity getResume(String userId) { logger.debug(\u0026#34;Fetching resume for user: {}\u0026#34;, userId); return resumeRepository.findByUserId(userId); } // 3. Improve Content with AI public String improveWithAI(String userId, String currentContent, String type) { // Validation if (currentContent == null || currentContent.isEmpty()) throw new IllegalArgumentException(\u0026#34;Current content is required\u0026#34;); if (type == null || type.isEmpty()) throw new IllegalArgumentException(\u0026#34;Type is required\u0026#34;); // Lấy thông tin User để biết Industry UserEntity user = userRepository.findById(\u0026#34;USER#\u0026#34; + userId, \u0026#34;METADATA\u0026#34;); if (user == null) throw new RuntimeException(\u0026#34;User not found\u0026#34;); String industry = user.getIndustry(); if (industry == null) industry = \u0026#34;General Professional\u0026#34;; // Fallback nếu chưa có ngành logger.info(\u0026#34;Improving resume section \u0026#39;{}\u0026#39; for industry \u0026#39;{}\u0026#39;\u0026#34;, type, industry); // Tạo Prompt cho Bedrock (Claude 3) String prompt = String.format(\u0026#34;\u0026#34;\u0026#34; As an expert resume writer, improve the following %s description for a %s professional. Make it more impactful, quantifiable, and aligned with industry standards. Current content: \u0026#34;%s\u0026#34; Requirements: 1. Use action verbs 2. Include metrics and results where possible 3. Highlight relevant technical skills 4. Keep it concise but detailed 5. Focus on achievements over responsibilities 6. Use industry-specific keywords Format the response as a single paragraph without any additional text or explanations. \u0026#34;\u0026#34;\u0026#34;, type, industry, currentContent); // Gọi AI return bedrockService.generateTextCorrection(prompt); } } 4. Function (Controller Layer) Module này cần xử lý 3 luồng chính: Lấy CV, Lưu CV và Gọi AI.\n@Configuration public class ResumeFunctions { private static final Logger logger = LoggerFactory.getLogger(ResumeFunctions.class); private final ResumeService resumeService; private final ObjectMapper objectMapper; public ResumeFunctions(ResumeService resumeService) { this.resumeService = resumeService; // --- CẤU HÌNH JACKSON THỦ CÔNG (THEO YÊU CẦU) --- this.objectMapper = new ObjectMapper(); // Cho phép đọc/ghi trực tiếp vào field (kể cả private) this.objectMapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY); // Bỏ qua lỗi nếu JSON có trường thừa this.objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); } /** * HÀM TỔNG (ROUTER) CHO RESUME */ @Bean public Function\u0026lt;Map\u0026lt;String, Object\u0026gt;, Map\u0026lt;String, Object\u0026gt;\u0026gt; resumeHandler() { return event -\u0026gt; { try { String path = extractPath(event); String method = extractHttpMethod(event); logger.info(\u0026#34;Resume Handler -\u0026gt; Path: {}, Method: {}\u0026#34;, path, method); Map\u0026lt;String, String\u0026gt; headers = normalizeHeaders(event); String userId = extractUserIdOrThrow(headers); // --- ROUTING --- // 1. GET /resume if (path.endsWith(\u0026#34;/resume\u0026#34;) \u0026amp;\u0026amp; \u0026#34;GET\u0026#34;.equalsIgnoreCase(method)) { return handleGetResume(userId); } // 2. POST /resume (Save) if (path.endsWith(\u0026#34;/resume\u0026#34;) \u0026amp;\u0026amp; \u0026#34;POST\u0026#34;.equalsIgnoreCase(method)) { return handleSaveResume(userId, event); } // 3. POST /resume/improve (AI Improve) if (path.endsWith(\u0026#34;/resume/improve\u0026#34;) \u0026amp;\u0026amp; \u0026#34;POST\u0026#34;.equalsIgnoreCase(method)) { return handleImproveResume(userId, event); } return buildResponse(404, Map.of(\u0026#34;error\u0026#34;, \u0026#34;Route not found\u0026#34;)); } catch (SecurityException e) { return buildResponse(401, Map.of(\u0026#34;error\u0026#34;, e.getMessage())); } catch (IllegalArgumentException e) { return buildResponse(400, Map.of(\u0026#34;error\u0026#34;, e.getMessage())); } catch (Exception e) { logger.error(\u0026#34;System Error\u0026#34;, e); return buildResponse(500, Map.of(\u0026#34;error\u0026#34;, e.getMessage())); } }; } // --- LOGIC CON --- private Map\u0026lt;String, Object\u0026gt; handleGetResume(String userId) { ResumeEntity resume = resumeService.getResume(userId); // Nếu chưa có resume, trả về null (frontend sẽ hiển thị form trống) return buildResponse(200, resume); } private Map\u0026lt;String, Object\u0026gt; handleSaveResume(String userId, Map\u0026lt;String, Object\u0026gt; event) throws Exception { String bodyString = extractBodyContent(event); // Parse thủ công để lấy field \u0026#39;content\u0026#39; JsonNode node = objectMapper.readTree(bodyString); if (!node.has(\u0026#34;content\u0026#34;)) { throw new IllegalArgumentException(\u0026#34;Field \u0026#39;content\u0026#39; is required\u0026#34;); } String content = node.get(\u0026#34;content\u0026#34;).asText(); ResumeEntity saved = resumeService.saveResume(userId, content); return buildResponse(200, saved); } private Map\u0026lt;String, Object\u0026gt; handleImproveResume(String userId, Map\u0026lt;String, Object\u0026gt; event) throws Exception { String bodyString = extractBodyContent(event); JsonNode node = objectMapper.readTree(bodyString); if (!node.has(\u0026#34;current\u0026#34;) || !node.has(\u0026#34;type\u0026#34;)) { throw new IllegalArgumentException(\u0026#34;Fields \u0026#39;current\u0026#39; and \u0026#39;type\u0026#39; are required\u0026#34;); } String current = node.get(\u0026#34;current\u0026#34;).asText(); String type = node.get(\u0026#34;type\u0026#34;).asText(); String improvedContent = resumeService.improveWithAI(userId, current, type); // Trả về JSON đơn giản return buildResponse(200, Map.of(\u0026#34;improvedContent\u0026#34;, improvedContent)); } // --- HELPERS (Đã được chuẩn hóa và format đẹp) --- private String extractPath(Map\u0026lt;String, Object\u0026gt; event) { return event.get(\u0026#34;rawPath\u0026#34;) != null ? event.get(\u0026#34;rawPath\u0026#34;).toString() : \u0026#34;\u0026#34;; } private String extractHttpMethod(Map\u0026lt;String, Object\u0026gt; event) { try { Map req = (Map) event.get(\u0026#34;requestContext\u0026#34;); if (req != null) { Map http = (Map) req.get(\u0026#34;http\u0026#34;); if (http != null) return http.get(\u0026#34;method\u0026#34;).toString(); } } catch (Exception e) { /* ignore */ } return \u0026#34;GET\u0026#34;; } private Map\u0026lt;String, String\u0026gt; normalizeHeaders(Map\u0026lt;String, Object\u0026gt; event) { Map\u0026lt;String, String\u0026gt; headers = new HashMap\u0026lt;\u0026gt;(); Object headersObj = event.get(\u0026#34;headers\u0026#34;); if (headersObj instanceof Map) { Map\u0026lt;?, ?\u0026gt; rawMap = (Map\u0026lt;?, ?\u0026gt;) headersObj; for (Map.Entry\u0026lt;?, ?\u0026gt; entry : rawMap.entrySet()) { if (entry.getKey() != null \u0026amp;\u0026amp; entry.getValue() != null) { headers.put(entry.getKey().toString().toLowerCase(), entry.getValue().toString()); } } } return headers; } private String extractUserIdOrThrow(Map\u0026lt;String, String\u0026gt; headers) { String authHeader = headers.get(\u0026#34;authorization\u0026#34;); if (authHeader == null || !authHeader.startsWith(\u0026#34;Bearer \u0026#34;)) { throw new SecurityException(\u0026#34;Missing or invalid Authorization header\u0026#34;); } try { String token = authHeader.substring(7); String[] parts = token.split(\u0026#34;\\\\.\u0026#34;); if (parts.length \u0026lt; 2) throw new SecurityException(\u0026#34;Invalid JWT format\u0026#34;); // QUAN TRỌNG: Dùng Base64UrlDecoder String payloadJson = new String(Base64.getUrlDecoder().decode(parts[1])); return objectMapper.readTree(payloadJson).get(\u0026#34;sub\u0026#34;).asText(); } catch (Exception e) { throw new SecurityException(\u0026#34;Token validation failed\u0026#34;); } } private String extractBodyContent(Map\u0026lt;String, Object\u0026gt; event) { Object bodyObj = event.get(\u0026#34;body\u0026#34;); if (bodyObj == null) return null; String bodyString; if (bodyObj instanceof String) { bodyString = (String) bodyObj; } else { try { bodyString = objectMapper.writeValueAsString(bodyObj); } catch (Exception e) { return \u0026#34;{}\u0026#34;; } } Object isBase64Obj = event.get(\u0026#34;isBase64Encoded\u0026#34;); if (isBase64Obj != null \u0026amp;\u0026amp; Boolean.parseBoolean(isBase64Obj.toString())) { try { bodyString = new String(Base64.getDecoder().decode(bodyString)); } catch (Exception e) { throw new RuntimeException(\u0026#34;Invalid Base64 body\u0026#34;); } } return bodyString; } private Map\u0026lt;String, Object\u0026gt; buildResponse(int statusCode, Object body) { Map\u0026lt;String, Object\u0026gt; response = new HashMap\u0026lt;\u0026gt;(); response.put(\u0026#34;statusCode\u0026#34;, statusCode); response.put(\u0026#34;headers\u0026#34;, Map.of(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;)); try { response.put(\u0026#34;body\u0026#34;, objectMapper.writeValueAsString(body)); } catch (Exception e) { response.put(\u0026#34;statusCode\u0026#34;, 500); response.put(\u0026#34;body\u0026#34;, \u0026#34;{\\\u0026#34;error\\\u0026#34;: \\\u0026#34;JSON Serialization Error\\\u0026#34;}\u0026#34;); } return response; } } "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/1-worklog/1.3-week3/","title":"Worklog Tuần 3","tags":[],"description":"","content":"Mục tiêu tuần 3: Hiểu và thực hành các cấu hình nâng cao của VPN và EC2 trên AWS. Biết cách thiết lập VPN nâng cao với StrongSwan, Transit Gateway và BGP Dynamic Routing để mở rộng kết nối mạng giữa các vùng và hệ thống. Nắm vững quản lý và vận hành EC2 nâng cao: thay đổi loại instance, tạo AMI tùy chỉnh, phục hồi truy cập khi mất Key Pair. Triển khai ứng dụng thực tế (Node.js và User Management) trên Amazon Linux 2 và Windows Server 2022. Quản lý quyền truy cập và giới hạn sử dụng tài nguyên bằng IAM Policy để tăng cường bảo mật hệ thống. Các công việc cần triển khai trong tuần này: Thứ Công việc Ngày bắt đầu Ngày hoàn thành Nguồn tài liệu 2 - Tìm hiểu cơ bản về cấu hình VPN nâng cao: + Cấu hình StrongSwan thay thế + Cấu hình bảo mật nâng cao + Cấu hình BGP Dynamic Routing + Giám sát và Troubleshooting nâng cao + Checklist triển khai Production - Tìm hiểu các vấn đề thường gặp trong quá trình thiết lập VPN và giải pháp cho từng hệ điều hành - Thực hành: Cấu hình VPN bằng StrongSwan với Transit Gateway + Tạo Customer Gateway + Tạo Transit Gateway + Tạo kết nối VPN + Tạo Transit Gateway Attachment + Cấu hình Route Tables cho Transit Gateway và VPC + Cấu hình Customer Gateway 22/09/2025 22/09/2025 cloudjourney.awsstudygroup.com 3 - Ôn tập kiến thức cơ bản về EC2: + Khái niệm, tính năng và cách hoạt động + Các loại instance (General Purpose, Compute Optimized, Memory Optimized, …) + AMI, EBS, Security Group, Key Pair + Cấu hình mạng, lưu trữ, quyền truy cập + Quy trình quản lý vòng đời (Start, Stop, Reboot, Terminate) - Thực hành: + Tạo VPC, Security Group cho Linux và Windows + Khởi tạo Windows Server 2022 instance + Kết nối từ máy tính đến Windows Server 2022 + Tạo Amazon Linux 2 instance + Kết nối đến Amazon Linux 2 bằng MobaXterm và PuTTY 23/09/2025 23/09/2025 cloudjourney.awsstudygroup.com 4 - Thực hành: Làm việc nâng cao với Amazon EC2 và các thành phần liên quan + Thay đổi EC2 Instance Type + Tạo Snapshot + Tạo Custom AMI + Tạo instance từ Custom AMI + Phục hồi truy cập khi mất Key Pair (Linux - User Data, Windows - SSM) - Tìm hiểu: + Giao diện Desktop cho EC2 Ubuntu 22.04 + EBS Snapshots Archive + Chia sẻ AMI 24/09/2025 24/09/2025 cloudjourney.awsstudygroup.com 5 - Thực hành: Triển khai ứng dụng Node.js trên Amazon Linux 2 + Chuẩn bị LAMP Web Server + Kiểm tra LAMP Web Server + Cấu hình bảo mật Database Server + Cài đặt phpMyAdmin + Triển khai ứng dụng trên Linux Instance - Thực hành: Triển khai ứng dụng AWS User Management trên Amazon EC2 (Windows Server 2022) + Cài đặt XAMPP trên Windows Server 2022 Base + Triển khai ứng dụng trên Windows Server 2022 instance 25/09/2025 26/09/2025 cloudjourney.awsstudygroup.com 6 - Tìm hiểu giới hạn sử dụng tài nguyên bằng dịch vụ IAM - Thực hành: + Cho phép sử dụng EC2 tại Region Singapore + Giới hạn EC2 theo Instance Family, Instance Type + Giới hạn EBS Volume Storage Type + Giới hạn quyền xóa EC2 theo địa chỉ IP doanh nghiệp + Giới hạn quyền xóa EC2 theo thời gian 26/09/2025 26/09/2025 cloudjourney.awsstudygroup.com Kết quả đạt được tuần 3: Hiểu sâu hơn về cấu hình và bảo mật VPN nâng cao: StrongSwan, Transit Gateway, BGP Dynamic Routing, giám sát và xử lý lỗi. Thực hành thiết lập VPN kết nối nhiều mạng VPC với cấu trúc linh hoạt và độ tin cậy cao. Củng cố kiến thức và kỹ năng triển khai EC2 trên cả Linux và Windows: Tạo, cấu hình và kết nối thành công đến EC2 instance. Quản lý tài nguyên (EBS, Security Group, AMI). Phục hồi truy cập khi mất Key Pair bằng User Data và SSM Session Manager. Quản lý AMI tùy chỉnh, sao lưu và khôi phục EC2 bằng Snapshot. Triển khai ứng dụng thực tế (Node.js và User Management) trên Amazon Linux 2 và Windows Server 2022. Áp dụng IAM Policy để giới hạn sử dụng tài nguyên, tăng cường bảo mật và kiểm soát chi phí hiệu quả. Hoàn thiện kỹ năng vận hành, triển khai và quản trị hạ tầng điện toán đám mây AWS ở mức thực hành nâng cao. "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/4-eventparticipated/","title":"Các events đã tham gia","tags":[],"description":"","content":"AWS First Cloud Journey Workforce OJT Fall 2025 Kick-off Tên sự kiện: AWS First Cloud Journey Workforce OJT Fall 2025 Kick-off\nThời gian: 09:00 ngày 06/09/2025\nĐịa điểm: Tầng 26, tòa nhà Bitexco, số 02 đường Hải Triều, phường Sài Gòn, thành phố Hồ Chí Minh\nVai trò trong sự kiện: Người tham dự\n"},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/5-workshop/5.4-backend-development/5.4.4-cover-letter-functions/","title":"Cover Letter Functions","tags":[],"description":"","content":"Trong bài này, chúng ta sẽ xây dựng chức năng Cover Letter Generator.\nKhác với Resume (CV) là dữ liệu tĩnh ít thay đổi, Cover Letter (Thư xin việc) cần được tùy biến (\u0026ldquo;tailor\u0026rdquo;) cho từng công ty và vị trí ứng tuyển. Đây là việc rất tốn thời gian nếu làm thủ công, nhưng lại là bài toán hoàn hảo cho AI.\nLuồng dữ liệu (Data Flow) Input: User cung cấp Tên công ty, Vị trí, và Mô tả công việc (Job Description - JD). Process: Backend ghép thông tin này thành một Prompt (Câu lệnh) gửi cho Claude 3. Output: AI trả về bài văn mẫu. Backend lưu vào DB và trả về Frontend. 1. Model (Entity Layer) Vì một người dùng có thể tạo nhiều thư xin việc cho nhiều công ty khác nhau, nên SK (Sort Key) sẽ là duy nhất cho mỗi lá thư (dùng UUID).\n@Data @DynamoDbBean public class CoverLetterEntity { private String pk; // Format: USER#\u0026lt;cognito_sub\u0026gt; private String sk; // Format: LETTER#\u0026lt;uuid\u0026gt; private String content; // Markdown do AI Bedrock viết private String jobDescription; private String companyName; private String jobTitle; private String status; // \u0026#34;draft\u0026#34;, \u0026#34;completed\u0026#34; private String createdAt; private String updatedAt; @DynamoDbPartitionKey @DynamoDbAttribute(\u0026#34;PK\u0026#34;) public String getPk() { return pk; } @DynamoDbSortKey @DynamoDbAttribute(\u0026#34;SK\u0026#34;) public String getSk() { return sk; } } Chiến lược khóa:\nPK: USER#{userId}. SK: LETTER#{uuid} (Ví dụ: LETTER#550e8400-e29b\u0026hellip;). 2. Repository (Data Access Layer) Chúng ta cần các hàm để Lưu, Lấy danh sách, và Xóa thư.\nKế thừa từ lớp cha AbstractDynamoRepository\n@Repository public class CoverLetterRepository extends AbstractDynamoRepository\u0026lt;CoverLetterEntity\u0026gt; { public CoverLetterRepository(DynamoDbEnhancedClient client) { super(client, CoverLetterEntity.class); } // Tìm tất cả Cover Letter của một User // PK: USER#\u0026lt;userId\u0026gt;, SK bắt đầu bằng LETTER# // Vì AbstractRepository đã có findAllByPartitionKey, ta chỉ cần gọi nó public List\u0026lt;CoverLetterEntity\u0026gt; findAllByUserId(String userId) { String pk = \u0026#34;USER#\u0026#34; + userId; // Lưu ý: findAllByPartitionKey sẽ lấy cả UserEntity và ResumeEntity nếu chung PK // Tuy nhiên, vì ta map TableSchema với CoverLetterEntity class, // SDK sẽ tự động filter hoặc map, nhưng để an toàn nhất với Single Table Design, // Ta nên dùng query với điều kiện SK begins_with \u0026#34;LETTER#\u0026#34; // (Để đơn giản trong demo này, giả sử hàm findAllByPartitionKey của bạn lọc được type, // hoặc ta chấp nhận lấy về rồi filter ở Service). // Cách tốt nhất: Viết query cụ thể ở đây return findAllByPartitionKey(pk); } public CoverLetterEntity findById(String userId, String letterId) { return super.findById(\u0026#34;USER#\u0026#34; + userId, \u0026#34;LETTER#\u0026#34; + letterId); } public void deleteById(String userId, String letterId) { super.delete(\u0026#34;USER#\u0026#34; + userId, \u0026#34;LETTER#\u0026#34; + letterId); } } 3. Service Đây là phần quan trọng nhất: Cách nói chuyện với AI.\nKết hợp với BedrockService để thực hiện chức năng generateCoverLetter bằng AI\n@Service public class CoverLetterService { private static final Logger logger = LoggerFactory.getLogger(CoverLetterService.class); private final CoverLetterRepository coverLetterRepository; private final UserRepository userRepository; private final BedrockService bedrockService; public CoverLetterService(CoverLetterRepository coverLetterRepository, UserRepository userRepository, BedrockService bedrockService) { this.coverLetterRepository = coverLetterRepository; this.userRepository = userRepository; this.bedrockService = bedrockService; } // 1. Generate Cover Letter (Create) public CoverLetterEntity generateCoverLetter(String userId, CoverLetterRequest request) { // Validate if (request.getJobTitle() == null || request.getCompanyName() == null || request.getJobDescription() == null) { throw new IllegalArgumentException(\u0026#34;Missing required fields (jobTitle, companyName, jobDescription)\u0026#34;); } // Lấy thông tin User để AI viết cho chuẩn UserEntity user = userRepository.findById(\u0026#34;USER#\u0026#34; + userId, \u0026#34;METADATA\u0026#34;); if (user == null) throw new RuntimeException(\u0026#34;User not found\u0026#34;); String skills = user.getSkills() != null ? String.join(\u0026#34;, \u0026#34;, user.getSkills()) : \u0026#34;Not specified\u0026#34;; // Prompt Engineering (Copy từ logic cũ của bạn) String prompt = String.format(\u0026#34;\u0026#34;\u0026#34; Write a professional cover letter for a %s position at %s. About the candidate: - Industry: %s - Years of Experience: %d - Skills: %s - Professional Background: %s Job Description: %s Requirements: 1. Use a professional, enthusiastic tone 2. Highlight relevant skills and experience 3. Show understanding of the company\u0026#39;s needs 4. Keep it concise (max 400 words) 5. Use proper business letter formatting in markdown 6. Include specific examples of achievements 7. Relate candidate\u0026#39;s background to job requirements Format the letter in markdown. Do not include any preamble or postscript. \u0026#34;\u0026#34;\u0026#34;, request.getJobTitle(), request.getCompanyName(), user.getIndustry(), user.getExperience(), skills, user.getBio(), request.getJobDescription() ); // Gọi Bedrock String aiContent = bedrockService.generateTextCorrection(prompt); // Tạo Entity lưu xuống DB CoverLetterEntity entity = new CoverLetterEntity(); String letterId = UUID.randomUUID().toString(); entity.setPk(\u0026#34;USER#\u0026#34; + userId); entity.setSk(\u0026#34;LETTER#\u0026#34; + letterId); // SK unique entity.setContent(aiContent); entity.setJobTitle(request.getJobTitle()); entity.setCompanyName(request.getCompanyName()); entity.setJobDescription(request.getJobDescription()); entity.setStatus(\u0026#34;completed\u0026#34;); entity.setCreatedAt(Instant.now().toString()); entity.setUpdatedAt(Instant.now().toString()); coverLetterRepository.save(entity); logger.info(\u0026#34;Generated cover letter {} for user {}\u0026#34;, letterId, userId); return entity; } // 2. Get All public List\u0026lt;CoverLetterEntity\u0026gt; getAllCoverLetters(String userId) { // Lấy về tất cả item của user, sau đó lọc ra những cái là Cover Letter // (Trong môi trường production nên dùng Query SK begins_with \u0026#34;LETTER#\u0026#34; để tối ưu) List\u0026lt;CoverLetterEntity\u0026gt; allItems = coverLetterRepository.findAllByUserId(userId); return allItems.stream() .filter(item -\u0026gt; item.getSk().startsWith(\u0026#34;LETTER#\u0026#34;)) .collect(Collectors.toList()); } // 3. Get One public CoverLetterEntity getCoverLetter(String userId, String letterId) { return coverLetterRepository.findById(userId, letterId); } // 4. Delete public void deleteCoverLetter(String userId, String letterId) { coverLetterRepository.deleteById(userId, letterId); logger.info(\u0026#34;Deleted cover letter {} for user {}\u0026#34;, letterId, userId); } } 4. Function (Router Layer) Hàm này cần xử lý nhiều API Endpoint hơn (List, Get One, Create, Delete).\n@Configuration public class CoverLetterFunctions { private static final Logger logger = LoggerFactory.getLogger(CoverLetterFunctions.class); private final CoverLetterService coverLetterService; private final ObjectMapper objectMapper; public CoverLetterFunctions(CoverLetterService coverLetterService) { this.coverLetterService = coverLetterService; // --- CẤU HÌNH JACKSON THỦ CÔNG (QUAN TRỌNG) --- // Giúp serialize được các object không có getter/setter chuẩn hoặc field private this.objectMapper = new ObjectMapper(); this.objectMapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY); this.objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); } /** * HÀM TỔNG (ROUTER) * Phân phối request dựa trên Path và Method */ @Bean public Function\u0026lt;Map\u0026lt;String, Object\u0026gt;, Map\u0026lt;String, Object\u0026gt;\u0026gt; coverLetterHandler() { return event -\u0026gt; { try { // 1. Trích xuất thông tin Request String path = extractPath(event); String method = extractHttpMethod(event); logger.info(\u0026#34;CoverLetter Router -\u0026gt; Path: [{}], Method: [{}]\u0026#34;, path, method); // 2. Xác thực User (Auth) Map\u0026lt;String, String\u0026gt; headers = normalizeHeaders(event); String userId = extractUserIdOrThrow(headers); // 3. Phân luồng xử lý (Routing) // Case 1: GET /cover-letters (List All) if (path.endsWith(\u0026#34;/cover-letters\u0026#34;) \u0026amp;\u0026amp; \u0026#34;GET\u0026#34;.equalsIgnoreCase(method)) { return handleListCoverLetters(userId); } // Case 2: POST /cover-letters (Generate) if (path.endsWith(\u0026#34;/cover-letters\u0026#34;) \u0026amp;\u0026amp; \u0026#34;POST\u0026#34;.equalsIgnoreCase(method)) { return handleGenerateCoverLetter(userId, event); } // Case 3: GET /cover-letters/{id} (Get One) if (path.contains(\u0026#34;/cover-letters/\u0026#34;) \u0026amp;\u0026amp; \u0026#34;GET\u0026#34;.equalsIgnoreCase(method)) { String id = extractId(event, path); return handleGetOneCoverLetter(userId, id); } // Case 4: DELETE /cover-letters/{id} if (path.contains(\u0026#34;/cover-letters/\u0026#34;) \u0026amp;\u0026amp; \u0026#34;DELETE\u0026#34;.equalsIgnoreCase(method)) { String id = extractId(event, path); return handleDeleteCoverLetter(userId, id); } return buildResponse(404, Map.of(\u0026#34;error\u0026#34;, \u0026#34;Route not found: \u0026#34; + path)); } catch (SecurityException e) { logger.warn(\u0026#34;Auth Error: {}\u0026#34;, e.getMessage()); return buildResponse(401, Map.of(\u0026#34;error\u0026#34;, e.getMessage())); } catch (IllegalArgumentException e) { logger.warn(\u0026#34;Validation Error: {}\u0026#34;, e.getMessage()); return buildResponse(400, Map.of(\u0026#34;error\u0026#34;, e.getMessage())); } catch (Exception e) { logger.error(\u0026#34;System Error\u0026#34;, e); return buildResponse(500, Map.of(\u0026#34;error\u0026#34;, e.getMessage())); } }; } // ========================================================================= // LOGIC CON (SUB-HANDLERS) // ========================================================================= private Map\u0026lt;String, Object\u0026gt; handleListCoverLetters(String userId) { logger.info(\u0026#34;Fetching all cover letters for user: {}\u0026#34;, userId); List\u0026lt;CoverLetterEntity\u0026gt; list = coverLetterService.getAllCoverLetters(userId); return buildResponse(200, list); } private Map\u0026lt;String, Object\u0026gt; handleGenerateCoverLetter(String userId, Map\u0026lt;String, Object\u0026gt; event) throws Exception { String bodyString = extractBodyContent(event); if (bodyString == null || bodyString.trim().isEmpty()) { throw new IllegalArgumentException(\u0026#34;Request body is required\u0026#34;); } logger.debug(\u0026#34;Generating cover letter with body: {}\u0026#34;, bodyString); CoverLetterRequest req = objectMapper.readValue(bodyString, CoverLetterRequest.class); CoverLetterEntity created = coverLetterService.generateCoverLetter(userId, req); logger.info(\u0026#34;Successfully generated cover letter. ID: {}\u0026#34;, created.getSk()); return buildResponse(200, created); } private Map\u0026lt;String, Object\u0026gt; handleGetOneCoverLetter(String userId, String letterId) { if (letterId == null || letterId.isEmpty()) throw new IllegalArgumentException(\u0026#34;ID is missing\u0026#34;); logger.info(\u0026#34;Fetching cover letter ID: {}\u0026#34;, letterId); CoverLetterEntity item = coverLetterService.getCoverLetter(userId, letterId); if (item == null) { return buildResponse(404, Map.of(\u0026#34;error\u0026#34;, \u0026#34;Cover letter not found\u0026#34;)); } return buildResponse(200, item); } private Map\u0026lt;String, Object\u0026gt; handleDeleteCoverLetter(String userId, String letterId) { if (letterId == null || letterId.isEmpty()) throw new IllegalArgumentException(\u0026#34;ID is missing\u0026#34;); logger.info(\u0026#34;Deleting cover letter ID: {}\u0026#34;, letterId); coverLetterService.deleteCoverLetter(userId, letterId); return buildResponse(200, Map.of(\u0026#34;status\u0026#34;, \u0026#34;deleted\u0026#34;, \u0026#34;id\u0026#34;, letterId)); } // ========================================================================= // HELPERS (Tiện ích) // ========================================================================= private String extractId(Map\u0026lt;String, Object\u0026gt; event, String path) { // Ưu tiên lấy từ Path Parameters của API Gateway if (event.get(\u0026#34;pathParameters\u0026#34;) instanceof Map) { Map\u0026lt;?, ?\u0026gt; params = (Map\u0026lt;?, ?\u0026gt;) event.get(\u0026#34;pathParameters\u0026#34;); if (params != null \u0026amp;\u0026amp; params.get(\u0026#34;id\u0026#34;) != null) { return params.get(\u0026#34;id\u0026#34;).toString(); } } // Fallback: Cắt chuỗi URL String[] parts = path.split(\u0026#34;/\u0026#34;); return parts.length \u0026gt; 0 ? parts[parts.length - 1] : null; } private String extractPath(Map\u0026lt;String, Object\u0026gt; event) { return event.get(\u0026#34;rawPath\u0026#34;) != null ? event.get(\u0026#34;rawPath\u0026#34;).toString() : \u0026#34;\u0026#34;; } private String extractHttpMethod(Map\u0026lt;String, Object\u0026gt; event) { try { Map req = (Map) event.get(\u0026#34;requestContext\u0026#34;); if (req != null) { Map http = (Map) req.get(\u0026#34;http\u0026#34;); if (http != null) return http.get(\u0026#34;method\u0026#34;).toString(); } } catch (Exception e) { /* ignore */ } return \u0026#34;GET\u0026#34;; } private Map\u0026lt;String, String\u0026gt; normalizeHeaders(Map\u0026lt;String, Object\u0026gt; event) { Map\u0026lt;String, String\u0026gt; headers = new HashMap\u0026lt;\u0026gt;(); Object headersObj = event.get(\u0026#34;headers\u0026#34;); if (headersObj instanceof Map) { Map\u0026lt;?, ?\u0026gt; rawMap = (Map\u0026lt;?, ?\u0026gt;) headersObj; for (Map.Entry\u0026lt;?, ?\u0026gt; entry : rawMap.entrySet()) { if (entry.getKey() != null \u0026amp;\u0026amp; entry.getValue() != null) { headers.put(entry.getKey().toString().toLowerCase(), entry.getValue().toString()); } } } return headers; } private String extractUserIdOrThrow(Map\u0026lt;String, String\u0026gt; headers) { String authHeader = headers.get(\u0026#34;authorization\u0026#34;); if (authHeader == null || !authHeader.startsWith(\u0026#34;Bearer \u0026#34;)) { throw new SecurityException(\u0026#34;Missing or invalid Authorization header\u0026#34;); } try { String token = authHeader.substring(7); String[] parts = token.split(\u0026#34;\\\\.\u0026#34;); if (parts.length \u0026lt; 2) throw new SecurityException(\u0026#34;Invalid JWT format\u0026#34;); // Dùng getUrlDecoder cho JWT String payloadJson = new String(Base64.getUrlDecoder().decode(parts[1])); return objectMapper.readTree(payloadJson).get(\u0026#34;sub\u0026#34;).asText(); } catch (Exception e) { logger.error(\u0026#34;Token decode error\u0026#34;, e); throw new SecurityException(\u0026#34;Token validation failed\u0026#34;); } } private String extractBodyContent(Map\u0026lt;String, Object\u0026gt; event) { Object bodyObj = event.get(\u0026#34;body\u0026#34;); if (bodyObj == null) return null; String bodyString; if (bodyObj instanceof String) { bodyString = (String) bodyObj; } else { try { bodyString = objectMapper.writeValueAsString(bodyObj); } catch (Exception e) { return \u0026#34;{}\u0026#34;; } } Object isBase64Obj = event.get(\u0026#34;isBase64Encoded\u0026#34;); if (isBase64Obj != null \u0026amp;\u0026amp; Boolean.parseBoolean(isBase64Obj.toString())) { try { bodyString = new String(Base64.getDecoder().decode(bodyString)); } catch (Exception e) { throw new RuntimeException(\u0026#34;Invalid Base64 body\u0026#34;); } } return bodyString; } private Map\u0026lt;String, Object\u0026gt; buildResponse(int statusCode, Object body) { Map\u0026lt;String, Object\u0026gt; response = new HashMap\u0026lt;\u0026gt;(); response.put(\u0026#34;statusCode\u0026#34;, statusCode); response.put(\u0026#34;headers\u0026#34;, Map.of(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;)); try { // Dùng objectMapper thủ công để serialize (tránh lỗi ClassCastException) response.put(\u0026#34;body\u0026#34;, objectMapper.writeValueAsString(body)); } catch (Exception e) { response.put(\u0026#34;statusCode\u0026#34;, 500); response.put(\u0026#34;body\u0026#34;, \u0026#34;{\\\u0026#34;error\\\u0026#34;: \\\u0026#34;JSON Serialization Error\\\u0026#34;}\u0026#34;); } return response; } } "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/5-workshop/5.4-backend-development/","title":"Phát triển Backend","tags":[],"description":"","content":"Trong phần này, chúng ta sẽ viết mã nguồn cho Backend sử dụng Java 17 và framework Spring Cloud Function.\nMục tiêu là biến các logic nghiệp vụ (Business Logic) thành các hàm độc lập (Functions) có thể chạy trên AWS Lambda.\nXem source code backend tại đây\n1. Cấu trúc Dự án (Project Structure) Dự án được xây dựng dựa trên Maven. Dưới đây là cấu trúc thư mục tiêu chuẩn:\nCác Package chính: model: Định nghĩa các Entity ánh xạ với DynamoDB (VD: UserEntity, ResumeEntity). repository: Interface giao tiếp với DynamoDB (sử dụng AWS SDK v2 Enhanced Client). service: Chứa logic nghiệp vụ và code gọi AI Bedrock. functions: Chứa các Bean Spring Cloud Function (Các điểm đầu vào của Lambda). dto: Các Data Transfer Object để nhận request từ Frontend. 2. Bài học quan trọng: Cấu hình ObjectMapper ⚠️ Trong quá trình phát triển, chúng ta đã gặp một lỗi nghiêm trọng: Backend trả về object rỗng {} hoặc lỗi 500 dù logic chạy đúng.\nNguyên nhân Mặc định, ObjectMapper của Jackson yêu cầu các class phải có Getter/Setter chuẩn (Java Bean standard) hoặc field phải là Public. Nếu Entity của chúng ta dùng Private field mà quên Getter, hoặc có cấu trúc phức tạp, Jackson sẽ không thể chuyển đổi (serialize) sang JSON.\nGiải pháp: Manual Configuration Thay vì dùng ObjectMapper mặc định của Spring, chúng ta tự khởi tạo và cấu hình \u0026ldquo;mạnh tay\u0026rdquo; hơn trong Constructor của các Function class:\npublic ResumeFunctions(ResumeService resumeService) { this.resumeService = resumeService; // --- CẤU HÌNH JACKSON THỦ CÔNG --- this.objectMapper = new ObjectMapper(); // 1. Cho phép đọc/ghi trực tiếp vào field (kể cả private) mà không cần Getter/Setter this.objectMapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY); // 2. Bỏ qua lỗi nếu JSON đầu vào có trường thừa mà Java class không có this.objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); } 3. AbstractDynamoRepository Lớp cha Generic Repository cho DynamoDB. Cung cấp các thao tác CRUD chuẩn, log và validate. @param Loại Entity (Ví dụ: UserEntity) public abstract class AbstractDynamoRepository\u0026lt;T\u0026gt; { // Logger chuẩn cho môi trường Production protected final Logger logger = LoggerFactory.getLogger(getClass()); protected final DynamoDbTable\u0026lt;T\u0026gt; table; protected final String tableName; public AbstractDynamoRepository(DynamoDbEnhancedClient client, Class\u0026lt;T\u0026gt; type) { this.tableName = System.getenv(\u0026#34;TABLE_NAME\u0026#34;); // 1. Validate Config ngay khi khởi động if (this.tableName == null || this.tableName.isEmpty()) { logger.error(\u0026#34;CRITICAL: Biến môi trường TABLE_NAME chưa được cấu hình!\u0026#34;); throw new RuntimeException(\u0026#34;Missing TABLE_NAME environment variable\u0026#34;); } this.table = client.table(tableName, TableSchema.fromBean(type)); logger.info(\u0026#34;Initialized Repository for entity {} with table {}\u0026#34;, type.getSimpleName(), tableName); } // ================================================================================== // 1. CREATE / UPDATE (Upsert) // ================================================================================== /** * Lưu hoặc cập nhật một Item. * Trong DynamoDB, putItem sẽ ghi đè toàn bộ item nếu PK/SK trùng. */ public void save(T item) { if (item == null) { throw new IllegalArgumentException(\u0026#34;Entity to save cannot be null\u0026#34;); } try { logger.debug(\u0026#34;Saving item to table {}: {}\u0026#34;, tableName, item); table.putItem(item); logger.info(\u0026#34;Successfully saved item.\u0026#34;); } catch (DynamoDbException e) { logger.error(\u0026#34;Failed to save item to DynamoDB: {}\u0026#34;, e.getMessage(), e); throw new RuntimeException(\u0026#34;Database Error: Could not save item\u0026#34;, e); } } /** * Cập nhật item (Chỉ cập nhật các trường có giá trị, giữ nguyên các trường khác). * Yêu cầu Entity phải có đủ PK và SK. */ public T update(T item) { if (item == null) { throw new IllegalArgumentException(\u0026#34;Entity to update cannot be null\u0026#34;); } try { logger.debug(\u0026#34;Updating item in table {}: {}\u0026#34;, tableName, item); // updateItem sẽ trả về item đã được update T updatedItem = table.updateItem(item); logger.info(\u0026#34;Successfully updated item.\u0026#34;); return updatedItem; } catch (DynamoDbException e) { logger.error(\u0026#34;Failed to update item: {}\u0026#34;, e.getMessage(), e); throw new RuntimeException(\u0026#34;Database Error: Could not update item\u0026#34;, e); } } // ================================================================================== // 2. READ (Find) // ================================================================================== public T findById(String pk, String sk) { // Validate input if (pk == null || pk.isEmpty() || sk == null || sk.isEmpty()) { logger.warn(\u0026#34;FindById called with empty keys. PK: {}, SK: {}\u0026#34;, pk, sk); return null; // Hoặc throw Exception tùy logic nghiệp vụ } try { Key key = Key.builder().partitionValue(pk).sortValue(sk).build(); logger.debug(\u0026#34;Fetching item with PK: {}, SK: {}\u0026#34;, pk, sk); T item = table.getItem(key); if (item == null) { logger.info(\u0026#34;Item not found for PK: {}, SK: {}\u0026#34;, pk, sk); } else { logger.debug(\u0026#34;Item found: {}\u0026#34;, item); } return item; } catch (DynamoDbException e) { logger.error(\u0026#34;Failed to find item: {}\u0026#34;, e.getMessage(), e); throw new RuntimeException(\u0026#34;Database Error: Could not fetch item\u0026#34;, e); } } /** * Tìm tất cả các Item có cùng Partition Key (PK). * Đây là thao tác QUERY (Hiệu năng cao, rẻ tiền). * Ví dụ: Lấy tất cả Resume, Letter, Assessment của User X (PK=USER#X) */ public List\u0026lt;T\u0026gt; findAllByPartitionKey(String pk) { if (pk == null || pk.isEmpty()) return new ArrayList\u0026lt;\u0026gt;(); try { QueryConditional queryConditional = QueryConditional.keyEqualTo( Key.builder().partitionValue(pk).build() ); logger.debug(\u0026#34;Querying items with PK: {}\u0026#34;, pk); // SDK trả về Iterable (Lazy load), ta convert sang List để dễ dùng PageIterable\u0026lt;T\u0026gt; result = table.query(queryConditional); List\u0026lt;T\u0026gt; items = result.items().stream().collect(Collectors.toList()); logger.info(\u0026#34;Found {} items for PK: {}\u0026#34;, items.size(), pk); return items; } catch (DynamoDbException e) { logger.error(\u0026#34;Failed to query items by PK: {}\u0026#34;, e.getMessage(), e); throw new RuntimeException(\u0026#34;Database Error: Could not query items\u0026#34;, e); } } /** * ⚠️ CẢNH BÁO: Quét toàn bộ bảng (SCAN). * Rất tốn kém Read Capacity Unit (RCU) và chậm nếu bảng lớn. * Chỉ dùng cho các bảng nhỏ (như Industry) hoặc debug. */ public List\u0026lt;T\u0026gt; findAll() { try { logger.warn(\u0026#34;PERFORMANCE WARNING: Executing full table SCAN on {}\u0026#34;, tableName); return table.scan().items().stream().collect(Collectors.toList()); } catch (DynamoDbException e) { logger.error(\u0026#34;Failed to scan table: {}\u0026#34;, e.getMessage(), e); throw new RuntimeException(\u0026#34;Database Error: Could not scan table\u0026#34;, e); } } // ================================================================================== // 3. DELETE // ================================================================================== public T delete(String pk, String sk) { if (pk == null || sk == null) { throw new IllegalArgumentException(\u0026#34;Keys cannot be null for deletion\u0026#34;); } try { Key key = Key.builder().partitionValue(pk).sortValue(sk).build(); logger.info(\u0026#34;Deleting item with PK: {}, SK: {}\u0026#34;, pk, sk); // deleteItem trả về item cũ trước khi xóa (nếu có) return table.deleteItem(key); } catch (DynamoDbException e) { logger.error(\u0026#34;Failed to delete item: {}\u0026#34;, e.getMessage(), e); throw new RuntimeException(\u0026#34;Database Error: Could not delete item\u0026#34;, e); } } } 4. BedrockService Lớp service này chuyên xử lý các tác vụ liên quan đến AI\n@Service public class BedrockService { private static final Logger logger = LoggerFactory.getLogger(BedrockService.class); private final BedrockRuntimeClient bedrockClient; private final ObjectMapper objectMapper; // Model ID lấy từ biến môi trường (Config trong template.yaml) private final String modelId = System.getenv(\u0026#34;BEDROCK_MODEL_ID\u0026#34;); public BedrockService(ObjectMapper objectMapper) { this.bedrockClient = BedrockRuntimeClient.builder().build(); // Tự lấy region từ môi trường this.objectMapper = objectMapper; } public IndustryInsightEntity generateIndustryInsights(String industry) { logger.info(\u0026#34;Calling AWS Bedrock to analyze industry: {}\u0026#34;, industry); String prompt = \u0026#34;\u0026#34;\u0026#34; Analyze the current state of the %s industry and provide insights in ONLY the following JSON format without any additional notes or explanations: { \u0026#34;salaryRanges\u0026#34;: [ { \u0026#34;role\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;min\u0026#34;: number, \u0026#34;max\u0026#34;: number, \u0026#34;median\u0026#34;: number, \u0026#34;location\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;growthRate\u0026#34;: number, \u0026#34;demandLevel\u0026#34;: \u0026#34;High\u0026#34; | \u0026#34;Medium\u0026#34; | \u0026#34;Low\u0026#34;, \u0026#34;topSkills\u0026#34;: [\u0026#34;skill1\u0026#34;, \u0026#34;skill2\u0026#34;], \u0026#34;marketOutlook\u0026#34;: \u0026#34;Positive\u0026#34; | \u0026#34;Neutral\u0026#34; | \u0026#34;Negative\u0026#34;, \u0026#34;keyTrends\u0026#34;: [\u0026#34;trend1\u0026#34;, \u0026#34;trend2\u0026#34;], \u0026#34;recommendedSkills\u0026#34;: [\u0026#34;skill1\u0026#34;, \u0026#34;skill2\u0026#34;] } IMPORTANT: Return ONLY the JSON. No additional text, notes, or markdown formatting. Include at least 5 common roles for salary ranges. Growth rate should be a percentage float (e.g., 5.5). Include at least 5 skills and trends. \u0026#34;\u0026#34;\u0026#34;.formatted(industry); // Cấu trúc Body cho Claude 3 Map\u0026lt;String, Object\u0026gt; payload = Map.of( \u0026#34;anthropic_version\u0026#34;, \u0026#34;bedrock-2023-05-31\u0026#34;, \u0026#34;max_tokens\u0026#34;, 2000, \u0026#34;messages\u0026#34;, java.util.List.of( Map.of(\u0026#34;role\u0026#34;, \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;, prompt) ) ); try { String payloadJson = objectMapper.writeValueAsString(payload); InvokeModelRequest request = InvokeModelRequest.builder() .modelId(modelId) .body(SdkBytes.fromUtf8String(payloadJson)) .contentType(\u0026#34;application/json\u0026#34;) .accept(\u0026#34;application/json\u0026#34;) .build(); InvokeModelResponse response = bedrockClient.invokeModel(request); String responseBody = response.body().asString(StandardCharsets.UTF_8); // Parse response của Claude để lấy phần text // Structure: { \u0026#34;content\u0026#34;: [ { \u0026#34;text\u0026#34;: \u0026#34;...\u0026#34; } ] } var jsonNode = objectMapper.readTree(responseBody); String aiText = jsonNode.get(\u0026#34;content\u0026#34;).get(0).get(\u0026#34;text\u0026#34;).asText(); // Clean text (remove markdown ```json ... ```) String cleanedJson = aiText.replaceAll(\u0026#34;```json\u0026#34;, \u0026#34;\u0026#34;).replaceAll(\u0026#34;```\u0026#34;, \u0026#34;\u0026#34;).trim(); logger.debug(\u0026#34;Cleaned AI JSON: {}\u0026#34;, cleanedJson); // Parse thành Entity return objectMapper.readValue(cleanedJson, IndustryInsightEntity.class); } catch (Exception e) { logger.error(\u0026#34;Failed to generate AI insights\u0026#34;, e); throw new RuntimeException(\u0026#34;AI Generation Failed: \u0026#34; + e.getMessage()); } } /** * Hàm gọi AI trả về Text thuần (dùng cho Resume improvement) */ public String generateTextCorrection(String prompt) { logger.info(\u0026#34;Calling Bedrock for Text Generation...\u0026#34;); // Cấu trúc Body cho Claude 3 Map\u0026lt;String, Object\u0026gt; payload = Map.of( \u0026#34;anthropic_version\u0026#34;, \u0026#34;bedrock-2023-05-31\u0026#34;, \u0026#34;max_tokens\u0026#34;, 1000, \u0026#34;messages\u0026#34;, java.util.List.of( Map.of(\u0026#34;role\u0026#34;, \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;, prompt) ) ); try { String payloadJson = objectMapper.writeValueAsString(payload); InvokeModelRequest request = InvokeModelRequest.builder() .modelId(modelId) .body(SdkBytes.fromUtf8String(payloadJson)) .contentType(\u0026#34;application/json\u0026#34;) .accept(\u0026#34;application/json\u0026#34;) .build(); InvokeModelResponse response = bedrockClient.invokeModel(request); String responseBody = response.body().asString(StandardCharsets.UTF_8); // Parse response: { \u0026#34;content\u0026#34;: [ { \u0026#34;text\u0026#34;: \u0026#34;...\u0026#34; } ] } var jsonNode = objectMapper.readTree(responseBody); String aiText = jsonNode.get(\u0026#34;content\u0026#34;).get(0).get(\u0026#34;text\u0026#34;).asText(); return aiText.trim(); } catch (Exception e) { logger.error(\u0026#34;Bedrock Text Generation Failed\u0026#34;, e); throw new RuntimeException(\u0026#34;AI Service Unavailable\u0026#34;); } } // Hàm mới: Tạo Quiz Questions public String generateQuizJson(String industry, String skills) { logger.info(\u0026#34;Generating Quiz for {} with skills {}\u0026#34;, industry, skills); String prompt = String.format(\u0026#34;\u0026#34;\u0026#34; Generate 10 technical interview questions for a %s professional with expertise in %s. Each question must be multiple choice with 4 options. Return the response in this JSON format only, no additional text, no markdown: { \u0026#34;questions\u0026#34;: [ { \u0026#34;question\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;options\u0026#34;: [\u0026#34;string\u0026#34;, \u0026#34;string\u0026#34;, \u0026#34;string\u0026#34;, \u0026#34;string\u0026#34;], \u0026#34;correctAnswer\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;explanation\u0026#34;: \u0026#34;string\u0026#34; } ] } \u0026#34;\u0026#34;\u0026#34;, industry, skills); return callBedrock(prompt); } // Hàm tái sử dụng logic gọi Bedrock private String callBedrock(String prompt) { // Logic giống hệt hàm generateTextCorrection cũ, chỉ thay prompt // (Bạn có thể refactor code cũ để dùng chung hàm này cho gọn) Map\u0026lt;String, Object\u0026gt; payload = Map.of( \u0026#34;anthropic_version\u0026#34;, \u0026#34;bedrock-2023-05-31\u0026#34;, \u0026#34;max_tokens\u0026#34;, 4000, // Tăng token vì JSON quiz khá dài \u0026#34;messages\u0026#34;, java.util.List.of(Map.of(\u0026#34;role\u0026#34;, \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;, prompt)) ); try { String payloadJson = objectMapper.writeValueAsString(payload); InvokeModelRequest request = InvokeModelRequest.builder() .modelId(modelId) .body(SdkBytes.fromUtf8String(payloadJson)) .contentType(\u0026#34;application/json\u0026#34;).accept(\u0026#34;application/json\u0026#34;).build(); InvokeModelResponse response = bedrockClient.invokeModel(request); String responseBody = response.body().asString(StandardCharsets.UTF_8); var jsonNode = objectMapper.readTree(responseBody); return jsonNode.get(\u0026#34;content\u0026#34;).get(0).get(\u0026#34;text\u0026#34;).asText().trim(); } catch (Exception e) { logger.error(\u0026#34;Bedrock Error\u0026#34;, e); throw new RuntimeException(\u0026#34;AI Error\u0026#34;); } } } Nội dung 5 Lambda Functions UserFunctions IndustryFunctions ResumeFuunctions CoverLetterFunctions AssessmentFunctions "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/1-worklog/1.4-week4/","title":"Worklog Tuần 4","tags":[],"description":"","content":"Mục tiêu tuần 4: Hiểu và thực hành các dịch vụ lưu trữ và phân phối nội dung cốt lõi của AWS, bao gồm S3, CloudFront, Cloud9, RDS và Lightsail. Biết cách triển khai, quản lý và bảo mật dữ liệu trong Amazon S3 (bao gồm Website Hosting, Versioning và Cross-Region Replication). Nắm được quy trình triển khai ứng dụng Web tĩnh và động sử dụng S3 + CloudFront + RDS + EC2. Làm quen với môi trường phát triển đám mây AWS Cloud9 và hiểu về AWS Well-Architected Framework để thiết kế hệ thống tối ưu. Biết cách triển khai nhanh ứng dụng mã nguồn mở (WordPress, PrestaShop) bằng Amazon Lightsail. Các công việc cần triển khai trong tuần này: Thứ Công việc Ngày bắt đầu Ngày hoàn thành Nguồn tài liệu 2 - Tìm hiểu cơ bản về AWS Cloud9 và thực hành: + Tạo Cloud9 instance + Sử dụng command line + Làm việc với file text + Sử dụng AWS CLI trên AWS Cloud9 - Tìm hiểu cơ bản về AWS S3 + Khái niệm và mục đích sử dụng dịch vụ lưu trữ đối tượng (Object Storage) + Cấu trúc Bucket và Object + Các lớp lưu trữ (Storage Classes) phổ biến + Quản lý quyền truy cập và chia sẻ dữ liệu (Public Access, Bucket Policy) - Thực hành: + Tạo S3 bucket + Tải dữ liệu lên S3 bucket + Bật tính năng lưu trữ website tĩnh + Cấu hình Block Public Access + Cấu hình truy cập đối tượng công khai + Kiểm tra Website đã host 29/09/2025 29/09/2025 cloudjourney.awsstudygroup.com 3 - Tìm hiểu cơ bản về Amazon CloudFront + Khái niệm dịch vụ CDN và vai trò của CloudFront trong phân phối nội dung + Cấu trúc cơ bản: Origin, Distribution, Edge Location + Cách CloudFront tăng tốc độ truy cập nội dung từ S3 - Tìm hiểu về S3 Versioning + Lợi ích chính của Versioning + Cách Versioning hoạt động + Trạng thái Versioning - Thực hành: + Chặn tất cả truy cập công cộng vào S3 + Tạo CloudFront Distribution phục vụ S3 Bucket + Kiểm tra Amazon CloudFront + Bật tính năng Versioning cho Bucket và thay đổi nội dung + Kiểm tra tính năng Versioning trên S3 và CloudFront 30/09/2025 30/09/2025 cloudjourney.awsstudygroup.com và aws.amazon.com/cloudfront 4 - Tìm hiểu về Amazon S3 Cross-Region Replication (CRR): + Lợi ích chính + Cách CRR hoạt động - Tìm hiểu về AWS Well-Architected Framework: + Khái niệm và sáu trụ cột kiến trúc tối ưu của AWS + Các ống kính kiến trúc tối ưu (Well-Architected Lenses) - Thực hành: + Di chuyển Object sang Bucket mới + Sao chép S3 Object sang Region khác - Tìm hiểu về thực hành tốt nhất \u0026amp; khắc phục sự cố AWS S3: + Bảo mật + Hiệu suất + Tối ưu chi phí + Lỗi thường gặp và cách khắc phục 01/10/2025 01/10/2025 cloudjourney.awsstudygroup.com và aws.amazon.com/architecture/well-architected 5 - Tìm hiểu cơ bản về Amazon RDS: + Giới thiệu dịch vụ cơ sở dữ liệu quan hệ (Relational Database Service) + Các loại cơ sở dữ liệu hỗ trợ (MySQL, PostgreSQL, MariaDB, v.v.) + Cấu trúc cơ bản: DB Instance, Subnet Group, Security Group - Thực hành: + Tạo VPC và SG cho EC2, RDS + Tạo DB Subnet Group + Tạo EC2 instance + Tạo RDS database instance + Triển khai ứng dụng + Backup và Restore trong Amazon RDS 02/10/2025 03/10/2025 cloudjourney.awsstudygroup.com 6 - Thực hành: Triển khai ứng dụng mã nguồn mở trên Amazon Lightsail và cấu hình tài nguyên: + Triển khai cơ sở dữ liệu trên Lightsail + Triển khai máy chủ WordPress + Cấu hình Ubuntu + Cấu hình Networking + Cấu hình WordPress + Triển khai PrestaShop E-Commerce Instance 03/10/2025 03/10/2025 cloudjourney.awsstudygroup.com Kết quả đạt được tuần 4: Làm quen và thao tác thành thạo trên AWS Cloud9, biết cách sử dụng CLI và quản lý tài nguyên qua môi trường phát triển đám mây. Hiểu rõ cách hoạt động của Amazon S3, biết tạo và cấu hình Bucket, triển khai Website tĩnh, Block Public Access và Versioning. Biết cách phân phối nội dung toàn cầu với Amazon CloudFront, tích hợp CloudFront với S3 để tăng tốc và bảo mật Website. Hiểu và thực hành được Cross-Region Replication (CRR) trong S3, áp dụng best practices về bảo mật, hiệu suất và chi phí. Triển khai được Amazon RDS và kết nối với EC2 Instance, thực hiện Backup/Restore cơ sở dữ liệu. Làm quen với AWS Well-Architected Framework, nắm được sáu trụ cột kiến trúc tối ưu của AWS. Triển khai và cấu hình thành công ứng dụng WordPress và PrestaShop trên Amazon Lightsail, hiểu cách quản lý tài nguyên và bảo mật cơ bản. "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/5-workshop/5.4-backend-development/5.4.5-assessment-functions/","title":"Assessment Functions","tags":[],"description":"","content":"Hàm AssessmentFunctions đóng vai trò là người phỏng vấn ảo. Nó thực hiện hai nhiệm vụ chính:\nGenerate Quiz: Tạo ra bộ câu hỏi trắc nghiệm \u0026ldquo;tươi mới\u0026rdquo; mỗi lần, dựa trên ngành nghề của người dùng. Save \u0026amp; History: Lưu lại kết quả làm bài để người dùng theo dõi sự tiến bộ qua biểu đồ. 1. Model (Entity Layer) Chúng ta cần lưu trữ kết quả của mỗi lần phỏng vấn.\n@Data @DynamoDbBean public class AssessmentEntity { private String pk; // Format: USER#\u0026lt;cognito_sub\u0026gt; private String sk; // Format: ASSESS#\u0026lt;uuid\u0026gt; private Double quizScore; private String category; // \u0026#34;Technical\u0026#34;, \u0026#34;Behavioral\u0026#34; private String improvementTip; // AI Bedrock generated tip // Nested Object List (JSON) private List\u0026lt;QuestionItem\u0026gt; questions; private String createdAt; private String updatedAt; @DynamoDbPartitionKey @DynamoDbAttribute(\u0026#34;PK\u0026#34;) public String getPk() { return pk; } @DynamoDbSortKey @DynamoDbAttribute(\u0026#34;SK\u0026#34;) public String getSk() { return sk; } // Inner Class cho cấu trúc câu hỏi @Data @DynamoDbBean public static class QuestionItem { private String question; private String answer; // Đáp án mẫu private String userAnswer; // Câu trả lời của user private Boolean isCorrect; private String explanation; // AI giải thích tại sao đúng/sai } } Chiến lược khóa:\nPK: USER#{userId}. SK: ASSESSMENT#{timestamp} (Sử dụng timestamp để sắp xếp lịch sử theo thời gian). 2. Repository (Data Access Layer) Kế thừa từ lớp cha AbstractDynamoRepository\n@Repository public class AssessmentRepository extends AbstractDynamoRepository\u0026lt;AssessmentEntity\u0026gt; { public AssessmentRepository(DynamoDbEnhancedClient client) { super(client, AssessmentEntity.class); } // Lấy lịch sử làm bài của User public List\u0026lt;AssessmentEntity\u0026gt; findAllByUserId(String userId) { // Query theo PK = USER#\u0026lt;id\u0026gt;, sau đó lọc SK bắt đầu bằng ASSESS# // (Cách tối ưu hơn là dùng Query Conditional BeginsWith trong SDK, // nhưng dùng findAllByPartitionKey lọc mềm cũng ổn với số lượng ít) List\u0026lt;AssessmentEntity\u0026gt; allItems = findAllByPartitionKey(\u0026#34;USER#\u0026#34; + userId); return allItems.stream() .filter(item -\u0026gt; item.getSk() != null \u0026amp;\u0026amp; item.getSk().startsWith(\u0026#34;ASSESS#\u0026#34;)) // Sắp xếp theo ngày tạo (Mới nhất lên đầu) - Logic Java .sorted((a, b) -\u0026gt; b.getCreatedAt().compareTo(a.getCreatedAt())) .collect(Collectors.toList()); } } 3. Service Kết hợp với BedrockService để thực hiện chức năng generateQuiz bằng AI\n@Service public class AssessmentService { private static final Logger logger = LoggerFactory.getLogger(AssessmentService.class); private final AssessmentRepository assessmentRepository; private final UserRepository userRepository; private final BedrockService bedrockService; private final ObjectMapper objectMapper; public AssessmentService(AssessmentRepository assessmentRepository, UserRepository userRepository, BedrockService bedrockService, ObjectMapper objectMapper) { this.assessmentRepository = assessmentRepository; this.userRepository = userRepository; this.bedrockService = bedrockService; this.objectMapper = objectMapper; } // 1. Generate Quiz public List\u0026lt;QuizQuestion\u0026gt; generateQuiz(String userId) { // Lấy thông tin User UserEntity user = userRepository.findById(\u0026#34;USER#\u0026#34; + userId, \u0026#34;METADATA\u0026#34;); if (user == null) throw new RuntimeException(\u0026#34;User not found\u0026#34;); String industry = user.getIndustry(); String skills = user.getSkills() != null ? String.join(\u0026#34;, \u0026#34;, user.getSkills()) : \u0026#34;\u0026#34;; // Gọi AI String jsonResponse = bedrockService.generateQuizJson(industry, skills); // Parse JSON trả về List Questions try { // Claude có thể trả về text kèm markdown, cần clean String cleanedJson = jsonResponse.replaceAll(\u0026#34;```json\u0026#34;, \u0026#34;\u0026#34;).replaceAll(\u0026#34;```\u0026#34;, \u0026#34;\u0026#34;).trim(); JsonNode root = objectMapper.readTree(cleanedJson); JsonNode questionsNode = root.get(\u0026#34;questions\u0026#34;); return Arrays.asList(objectMapper.treeToValue(questionsNode, QuizQuestion[].class)); } catch (Exception e) { logger.error(\u0026#34;Failed to parse Quiz JSON\u0026#34;, e); throw new RuntimeException(\u0026#34;Failed to parse AI response\u0026#34;); } } // 2. Save Result \u0026amp; Generate Tip public AssessmentEntity saveQuizResult(String userId, SaveAssessmentRequest request) { UserEntity user = userRepository.findById(\u0026#34;USER#\u0026#34; + userId, \u0026#34;METADATA\u0026#34;); if (user == null) throw new RuntimeException(\u0026#34;User not found\u0026#34;); List\u0026lt;QuestionItem\u0026gt; questionResults = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; wrongAnswersText = new ArrayList\u0026lt;\u0026gt;(); // Map DTO sang Entity và tìm câu sai for (int i = 0; i \u0026lt; request.getQuestions().size(); i++) { QuizQuestion q = request.getQuestions().get(i); String userAnswer = request.getUserAnswers().get(i); boolean isCorrect = q.getCorrectAnswer().equals(userAnswer); QuestionItem item = new QuestionItem(); item.setQuestion(q.getQuestion()); item.setAnswer(q.getCorrectAnswer()); item.setUserAnswer(userAnswer); item.setIsCorrect(isCorrect); item.setExplanation(q.getExplanation()); questionResults.add(item); if (!isCorrect) { wrongAnswersText.add(String.format(\u0026#34;Question: \\\u0026#34;%s\\\u0026#34;\\nCorrect: \\\u0026#34;%s\\\u0026#34;\\nUser Answer: \\\u0026#34;%s\\\u0026#34;\u0026#34;, q.getQuestion(), q.getCorrectAnswer(), userAnswer)); } } // Tạo Improvement Tip nếu có câu sai String improvementTip = null; if (!wrongAnswersText.isEmpty()) { String prompt = String.format(\u0026#34;\u0026#34;\u0026#34; The user got the following %s technical interview questions wrong: %s Based on these mistakes, provide a concise, specific improvement tip. Focus on knowledge gaps. Keep it under 2 sentences. Encouraging tone. \u0026#34;\u0026#34;\u0026#34;, user.getIndustry(), String.join(\u0026#34;\\n\\n\u0026#34;, wrongAnswersText)); improvementTip = bedrockService.generateTextCorrection(prompt); // Tái sử dụng hàm sinh text } // Lưu DB AssessmentEntity entity = new AssessmentEntity(); entity.setPk(\u0026#34;USER#\u0026#34; + userId); entity.setSk(\u0026#34;ASSESS#\u0026#34; + UUID.randomUUID().toString()); entity.setQuizScore(request.getScore()); entity.setCategory(\u0026#34;Technical\u0026#34;); entity.setImprovementTip(improvementTip); entity.setQuestions(questionResults); // DynamoDB Enhanced tự convert List sang JSON entity.setCreatedAt(Instant.now().toString()); entity.setUpdatedAt(Instant.now().toString()); assessmentRepository.save(entity); return entity; } // 3. Get History public List\u0026lt;AssessmentEntity\u0026gt; getAssessments(String userId) { return assessmentRepository.findAllByUserId(userId); } } 4. Function (Router Layer) Hàm này xử lý 3 endpoints khác nhau cho quy trình phỏng vấn.\n@Configuration public class AssessmentFunctions { private static final Logger logger = LoggerFactory.getLogger(AssessmentFunctions.class); private final AssessmentService assessmentService; private final ObjectMapper objectMapper; public AssessmentFunctions(AssessmentService assessmentService) { this.assessmentService = assessmentService; // --- CẤU HÌNH JACKSON THỦ CÔNG --- // Đảm bảo parse được mọi loại object, kể cả private fields this.objectMapper = new ObjectMapper(); this.objectMapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY); this.objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); } /** * HÀM TỔNG (ROUTER) CHO ASSESSMENT */ @Bean public Function\u0026lt;Map\u0026lt;String, Object\u0026gt;, Map\u0026lt;String, Object\u0026gt;\u0026gt; assessmentHandler() { return event -\u0026gt; { try { // 1. Trích xuất thông tin Request String path = extractPath(event); String method = extractHttpMethod(event); logger.info(\u0026#34;Assessment Router -\u0026gt; Path: [{}], Method: [{}]\u0026#34;, path, method); // 2. Xác thực User (Auth) Map\u0026lt;String, String\u0026gt; headers = normalizeHeaders(event); String userId = extractUserIdOrThrow(headers); // 3. Phân luồng xử lý (Routing) // Case 1: POST /interview/generate (Generate Quiz) if (path.endsWith(\u0026#34;/interview/generate\u0026#34;) \u0026amp;\u0026amp; \u0026#34;POST\u0026#34;.equalsIgnoreCase(method)) { return handleGenerateQuiz(userId); } // Case 2: POST /interview/save (Save Result) if (path.endsWith(\u0026#34;/interview/save\u0026#34;) \u0026amp;\u0026amp; \u0026#34;POST\u0026#34;.equalsIgnoreCase(method)) { return handleSaveQuizResult(userId, event); } // Case 3: GET /interview/history (Get List) if (path.endsWith(\u0026#34;/interview/history\u0026#34;) \u0026amp;\u0026amp; \u0026#34;GET\u0026#34;.equalsIgnoreCase(method)) { return handleGetAssessmentHistory(userId); } return buildResponse(404, Map.of(\u0026#34;error\u0026#34;, \u0026#34;Route not found: \u0026#34; + path)); } catch (SecurityException e) { logger.warn(\u0026#34;Auth Error: {}\u0026#34;, e.getMessage()); return buildResponse(401, Map.of(\u0026#34;error\u0026#34;, e.getMessage())); } catch (IllegalArgumentException e) { logger.warn(\u0026#34;Validation Error: {}\u0026#34;, e.getMessage()); return buildResponse(400, Map.of(\u0026#34;error\u0026#34;, e.getMessage())); } catch (Exception e) { logger.error(\u0026#34;System Error\u0026#34;, e); return buildResponse(500, Map.of(\u0026#34;error\u0026#34;, e.getMessage())); } }; } // ========================================================================= // LOGIC CON (SUB-HANDLERS) // ========================================================================= private Map\u0026lt;String, Object\u0026gt; handleGenerateQuiz(String userId) { logger.info(\u0026#34;Generating interview quiz for user: {}\u0026#34;, userId); // Gọi Service (Có thể mất thời gian do gọi AI) List\u0026lt;QuizQuestion\u0026gt; quiz = assessmentService.generateQuiz(userId); logger.info(\u0026#34;Generated {} questions successfully.\u0026#34;, quiz.size()); return buildResponse(200, Map.of(\u0026#34;questions\u0026#34;, quiz)); } private Map\u0026lt;String, Object\u0026gt; handleSaveQuizResult(String userId, Map\u0026lt;String, Object\u0026gt; event) throws Exception { String bodyString = extractBodyContent(event); if (bodyString == null || bodyString.trim().isEmpty()) { throw new IllegalArgumentException(\u0026#34;Request body is required for saving result\u0026#34;); } logger.debug(\u0026#34;Saving quiz result payload: {}\u0026#34;, bodyString); // Parse JSON sang DTO SaveAssessmentRequest req = objectMapper.readValue(bodyString, SaveAssessmentRequest.class); // Validate cơ bản DTO if (req.getQuestions() == null || req.getQuestions().isEmpty()) { throw new IllegalArgumentException(\u0026#34;Questions list cannot be empty\u0026#34;); } // Gọi Service AssessmentEntity result = assessmentService.saveQuizResult(userId, req); logger.info(\u0026#34;Saved assessment result ID: {}\u0026#34;, result.getSk()); return buildResponse(200, result); } private Map\u0026lt;String, Object\u0026gt; handleGetAssessmentHistory(String userId) { logger.info(\u0026#34;Fetching assessment history for user: {}\u0026#34;, userId); List\u0026lt;AssessmentEntity\u0026gt; list = assessmentService.getAssessments(userId); logger.info(\u0026#34;Found {} past assessments.\u0026#34;, list.size()); return buildResponse(200, list); } // ========================================================================= // HELPERS (Tiện ích - Copy y hệt từ các file trước) // ========================================================================= private String extractPath(Map\u0026lt;String, Object\u0026gt; event) { return event.get(\u0026#34;rawPath\u0026#34;) != null ? event.get(\u0026#34;rawPath\u0026#34;).toString() : \u0026#34;\u0026#34;; } private String extractHttpMethod(Map\u0026lt;String, Object\u0026gt; event) { try { Map req = (Map) event.get(\u0026#34;requestContext\u0026#34;); if (req != null) { Map http = (Map) req.get(\u0026#34;http\u0026#34;); if (http != null) return http.get(\u0026#34;method\u0026#34;).toString(); } } catch (Exception e) { /* ignore */ } return \u0026#34;GET\u0026#34;; } private Map\u0026lt;String, String\u0026gt; normalizeHeaders(Map\u0026lt;String, Object\u0026gt; event) { Map\u0026lt;String, String\u0026gt; headers = new HashMap\u0026lt;\u0026gt;(); Object headersObj = event.get(\u0026#34;headers\u0026#34;); if (headersObj instanceof Map) { Map\u0026lt;?, ?\u0026gt; rawMap = (Map\u0026lt;?, ?\u0026gt;) headersObj; for (Map.Entry\u0026lt;?, ?\u0026gt; entry : rawMap.entrySet()) { if (entry.getKey() != null \u0026amp;\u0026amp; entry.getValue() != null) { headers.put(entry.getKey().toString().toLowerCase(), entry.getValue().toString()); } } } return headers; } private String extractUserIdOrThrow(Map\u0026lt;String, String\u0026gt; headers) { String authHeader = headers.get(\u0026#34;authorization\u0026#34;); if (authHeader == null || !authHeader.startsWith(\u0026#34;Bearer \u0026#34;)) { throw new SecurityException(\u0026#34;Missing or invalid Authorization header\u0026#34;); } try { String token = authHeader.substring(7); String[] parts = token.split(\u0026#34;\\\\.\u0026#34;); if (parts.length \u0026lt; 2) throw new SecurityException(\u0026#34;Invalid JWT format\u0026#34;); // Dùng getUrlDecoder cho JWT chuẩn String payloadJson = new String(Base64.getUrlDecoder().decode(parts[1])); return objectMapper.readTree(payloadJson).get(\u0026#34;sub\u0026#34;).asText(); } catch (Exception e) { logger.error(\u0026#34;Token decode error\u0026#34;, e); throw new SecurityException(\u0026#34;Token validation failed\u0026#34;); } } private String extractBodyContent(Map\u0026lt;String, Object\u0026gt; event) { Object bodyObj = event.get(\u0026#34;body\u0026#34;); if (bodyObj == null) return null; String bodyString; if (bodyObj instanceof String) { bodyString = (String) bodyObj; } else { try { bodyString = objectMapper.writeValueAsString(bodyObj); } catch (Exception e) { return \u0026#34;{}\u0026#34;; } } Object isBase64Obj = event.get(\u0026#34;isBase64Encoded\u0026#34;); if (isBase64Obj != null \u0026amp;\u0026amp; Boolean.parseBoolean(isBase64Obj.toString())) { try { bodyString = new String(Base64.getDecoder().decode(bodyString)); } catch (Exception e) { throw new RuntimeException(\u0026#34;Invalid Base64 body\u0026#34;); } } return bodyString; } private Map\u0026lt;String, Object\u0026gt; buildResponse(int statusCode, Object body) { Map\u0026lt;String, Object\u0026gt; response = new HashMap\u0026lt;\u0026gt;(); response.put(\u0026#34;statusCode\u0026#34;, statusCode); response.put(\u0026#34;headers\u0026#34;, Map.of(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;)); try { // Dùng objectMapper thủ công để serialize response.put(\u0026#34;body\u0026#34;, objectMapper.writeValueAsString(body)); } catch (Exception e) { response.put(\u0026#34;statusCode\u0026#34;, 500); response.put(\u0026#34;body\u0026#34;, \u0026#34;{\\\u0026#34;error\\\u0026#34;: \\\u0026#34;JSON Serialization Error\\\u0026#34;}\u0026#34;); } return response; } } "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/5-workshop/5.5-frontend-development/","title":"Phát triển Frontend","tags":[],"description":"","content":"Frontend của AI Career Coach không chỉ cần đẹp mà còn phải xử lý logic phức tạp như Markdown Editor, Quiz Game và gọi API bảo mật.\nXem source code đầy đủ Frontend tại đây\nDưới đây tôi chỉ trình bày những nội dung chính và những gì cần lưu ý khi xây dựng frontend\n1. Khởi tạo Dự án (Tech Stack Setup) Chúng ta sử dụng Vite để khởi tạo dự án React vì tốc độ build cực nhanh.\nCác thư viện chính: Tailwind CSS: Framework CSS ưu tiên tiện ích (utility-first). Shadcn UI: Bộ thư viện component đẹp mắt (Button, Input, Card, Accordion\u0026hellip;) giúp chúng ta không phải code CSS từ con số 0. AWS Amplify: Thư viện giúp kết nối React với Cognito dễ dàng. React Router Dom: Để điều hướng giữa các trang. npm create vite@latest frontend -- --template react cd frontend npm install Thư viện cần cài đặt\nnpm install react-router-dom aws-amplify @aws-amplify/ui-react lucide-react react-hook-form zod @hookform/resolvers sonner @uiw/react-md-editor recharts html2pdf.js react-spinners date-fns clsx tailwind-merge class-variance-authority 2. Cấu hình Authentication với AWS Amplify Thay vì tự viết trang Login/Register phức tạp, chúng ta sử dụng component của Amplify. Nó tự động sinh ra giao diện đăng nhập/đăng ký đầy đủ tính năng.\nCấu hình trong main.jsx: Bạn cần lấy UserPoolId và ClientId từ phần Output của lệnh sam deploy ở bài trước để điền vào đây.\nimport { Amplify } from \u0026#39;aws-amplify\u0026#39;; Amplify.configure({ Auth: { Cognito: { userPoolId: \u0026#39;ap-southeast-1_XXXXXXX\u0026#39;, // \u0026lt;-- Thay bằng ID của bạn userPoolClientId: \u0026#39;xxxxxxxxxxxxxxxxx\u0026#39;, // \u0026lt;-- Thay bằng Client ID của bạn loginWith: { email: true } } } }); 3. apiClient Đây là phần quan trọng nhất khi tích hợp (Integration).\nVấn đề gặp phải:\nKhi Backend Java trả về dữ liệu, đôi khi nó trả về một chuỗi JSON lồng trong một chuỗi JSON khác (Double Serialization).\nVí dụ Backend trả: { statusCode: 200, body: \u0026ldquo;{\u0026quot;pk\u0026quot;: \u0026quot;USER#1\u0026quot;, \u0026hellip;}\u0026rdquo; } Frontend nếu chỉ response.json() sẽ nhận được chuỗi string trong body, không thể truy cập data.pk được. Giải pháp: Wrapper apiClient\nChúng ta viết một hàm wrapper để:\nTự động lấy JWT Token từ session hiện tại. Gắn Token vào Header Authorization. Tự động parse JSON 2 lần nếu phát hiện dữ liệu bị lồng. // src/lib/api.js export const apiClient = async (endpoint, options = {}) =\u0026gt; { // 1. Lấy Token const session = await fetchAuthSession(); const token = session.tokens?.idToken?.toString(); // 2. Gọi API với Token const response = await fetch(`${BASE_URL}${endpoint}`, { headers: { \u0026#39;Authorization\u0026#39;: `Bearer ${token}`, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, }, ...options, }); // 3. Xử lý \u0026#34;Double JSON\u0026#34; const data = await response.json(); if (data.body \u0026amp;\u0026amp; typeof data.body === \u0026#39;string\u0026#39;) { return JSON.parse(data.body); // \u0026lt;-- \u0026#34;Bóc vỏ\u0026#34; lần 2 } return data; }; 4. Xây dựng các trang chức năng (Core Features) A. Dashboard (Bảng điều khiển) Trang tổng quan hiển thị thống kê.\nThách thức: Xử lý bất đồng bộ khi gọi API lấy lịch sử hoạt độn Giải pháp: Sử dụng useEffect để fetch dữ liệu và hiển thị BarLoader (loading spinner) trong lúc chờ. B. Resume Builder (Trình tạo CV) Đây là tính năng phức tạp nhất về mặt UI.\nGiao diện: Sử dụng Tabs để chuyển đổi giữa chế độ Edit Form và Markdown Preview. Form: Sử dụng react-hook-form và zod để validate dữ liệu đầu vào. AI Feature: Khi người dùng bấm \u0026ldquo;Improve with AI\u0026rdquo;, Frontend gửi đoạn text thô lên API /resume/improve và điền lại kết quả vào ô input. Accordion UI: Sử dụng component Accordion của Shadcn để gom nhóm các mục Kinh nghiệm/Học vấn cho gọn gàng. C. Mock Interview (Phỏng vấn thử) Trang trắc nghiệm kiến thức.\nLogic tính điểm: So sánh đáp án người dùng chọn với đáp án đúng từ Backend. Lưu ý kỹ thuật: Backend trả về đáp án đúng là ký tự \u0026ldquo;B\u0026rdquo;, nhưng Frontend hiển thị là \u0026ldquo;B. Nội dung\u0026hellip;\u0026rdquo;. Code xử lý: userAnswer.split(\u0026quot;.\u0026quot;)[0].trim() === correctAnswer. D. Cover Letter Generator (Tạo thư xin việc) Đây là tính năng giúp người dùng tạo thư xin việc tự động dựa trên mô tả công việc (JD).\nLuồng xử lý:\nNgười dùng nhập: Tên công ty, Vị trí ứng tuyển, Mô tả công việc (JD). Frontend gửi POST /cover-letters lên Backend. Backend gọi Claude 3 để viết thư và lưu vào DB. Frontend nhận kết quả và hiển thị cho người dùng. Lưu ý kỹ thuật:\nLoading State: Vì AI mất khoảng 5-10 giây để viết xong một lá thư, Frontend bắt buộc phải có trạng thái chờ (Loading Spinner hoặc Skeleton) để người dùng biết hệ thống đang xử lý, tránh việc họ bấm nút nhiều lần. Hiển thị kết quả: Nội dung trả về là văn bản thuần (hoặc Markdown), cần hiển thị trong textarea hoặc MDEditor để người dùng có thể chỉnh sửa lại trước khi tải về. "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/1-worklog/1.5-week5/","title":"Worklog Tuần 5","tags":[],"description":"","content":"Mục tiêu tuần 5: Làm quen với các khái niệm về mở rộng hệ thống (Load Balancer, Auto Scaling) và biết cách triển khai thực tế trên AWS. Nắm được quy trình triển khai ứng dụng và cơ sở dữ liệu bằng RDS, quản lý ảnh máy (AMI) và tạo Launch Template. Hiểu và ứng dụng CloudWatch để giám sát tài nguyên, theo dõi logs, tạo metric, alarm, và dashboard. Tìm hiểu cơ bản về Route 53, DNS resolver và tích hợp với Microsoft AD trong môi trường cloud. Các công việc cần triển khai trong tuần này: Thứ Công việc Ngày bắt đầu Ngày hoàn thành Nguồn tài liệu 2 - Thực hành + Triển khai Akaunting Instance + Tạo instance + Cấu hình Networking + Triển khai Prestashop E-Commerce + Bảo mật ứng dụng Wordpress + Tạo bản Snapshot + Dịch chuyển sang instance lớn hơn + Tạo cảnh báo để thông báo cho quản trị viên nếu một sự kiện cụ thể xảy ra - Tìm hiểu về Auto Scaling Group, AMIs và Launch Template - Thực hành + Thiết lập hạ tầng mạng cơ bản cho ứng dụng FCJ Management + VPC và Subnet + Internet Gateway + Route Table + Security Groups + Tạo EC2 Instance + Tạo DB Subnet Group cho Amazon RDS + Tạo Amazon RDS Database Instance + Cài đặt dữ liệu cho Database + Triển khai máy chủ web + Chuẩn bị dữ liệu cho Predictive scaling + Tạo Amazon Machine Images (AMIs) từ EC2 + Tạo Launch Templates 06/10/2025 06/10/2025 cloudjourney.awsstudygroup.com 3 - Tìm hiểu về Elastic Load Balancing (ELB) + Target Group + Application Load Balancer + Network Load Balancer + Classic Load Balancer + Gateway Load Balancer - Tìm hiểu về Các giải pháp / kỹ thuật scaling + Manual scaling + Scheduled scaling + Dynamic scaling + Predictive scaling - Thực hành: + Tạo Target Group + Tạo Application Load Balancer + Kiểm tra kết quả triển khai Elastic Load Balancing (ELB) + Tạo Auto Scaling Group + kết nối ASG với Load Balancer + Thiết lập Size và Scaling Policies + Thiết lập thông báo - Thực hành Các giải pháp / kỹ thuật scaling + Manual scaling + Scheduled scaling + Dynamic scaling + Predictive scaling 07/10/2025 07/10/2025 cloudjourney.awsstudygroup.com và youtube của AWS Study Group 4 - Tìm hiểu về AWS CloudWatch + Tính năng + Container Insights + Lợi ích chính - Tìm hiểu về CloudWatch Metric, CloudWatch Logs, CloudWatch Alarms, CloudWatch Dashboards 08/10/2025 08/10/2025 cloudjourney.awsstudygroup.com 5 - Thực hành: + Triển khai CloudFormation Stack + Xem các Metrics + Thao tác với biểu đồ trong CloudWatch + Thực hiện các phép tìm kiếm Metrics + Thực hiện các phép toán học + Tạo dynamic labels + Xem CloudWatch Logs + Tạo logs từ một ứng dụng, sau đó là sẽ query những logs này ở trong CloudWatch Logs Insights + Trích xuất dữ liệu có giá trị từ logs và chuyển đổi chúng thành các metrics bằng CloudWatch Metric Filters + Thiết lập Alarm cho Error Log Metric + Tạo một Dashboard đơn giản để tập trung quản lý các Metrics và Alarms 09/10/2025 10/10/2025 cloudjourney.awsstudygroup.com 6 - Tìm hiểu về Route 53 + Outbound Endpoints + Inbound Endpoints + Route 53 Resolver Rules - Tìm hiểu về AWS Quick Starts, AWS CloudFormation, AWS Directory Service - Thực hành: + Tạo Key Pair, khởi tạo CloudFormation Template, cấu hình Security Group + Kết nối đến RDGW + Triển khai Microsoft AD + Thiết lập DNS + Tạo Route 53 Outbound Endpoint + Tạo Route 53 Resolver Rules + Tạo Route 53 Inbound Endpoints + Thử nghiệm kết quả 10/10/2025 10/10/2025 cloudjourney.awsstudygroup.com Kết quả đạt được tuần 5: Triển khai và quản lý các ứng dụng web trên EC2/Lightsail, bao gồm Akaunting, WordPress và Prestashop, kèm theo cấu hình bảo mật, snapshot và nâng cấp instance. Thiết lập Auto Scaling Group, Launch Template và AMI để mở rộng hệ thống, áp dụng các phương pháp scaling: manual, scheduled, dynamic, predictive. Tạo và quản lý Load Balancer (ALB, NLB) kết nối với Auto Scaling Group để cân bằng tải và đảm bảo hệ thống ổn định. Giám sát hệ thống bằng CloudWatch: Metrics, Logs, Alarms, Dashboard và trích xuất dữ liệu từ logs để theo dõi hiệu suất. Triển khai cơ sở dữ liệu với Amazon RDS, thiết lập DB Subnet Group và kết nối EC2 với RDS để ứng dụng hoạt động hoàn chỉnh. Tìm hiểu và thực hành Route 53, triển khai DNS nội bộ, Microsoft AD, cấu hình Resolver Rules và kiểm tra kết nối. "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/5-workshop/","title":"Workshop","tags":[],"description":"","content":"Xây dựng AI Career Coach - một ứng dụng Fullstack Serverless hiện đại giúp người dùng nâng cao cơ hội nghề nghiệp thông qua sức mạnh của trí tuệ nhân tạo 🎥 Demo Sản Phẩm Xem video\n💡 Vấn đề \u0026amp; Giải pháp Vấn đề Thị trường việc làm ngày càng cạnh tranh. Ứng viên thường gặp khó khăn trong việc:\nViết một bản CV (Resume) chuẩn chỉnh, tối ưu cho hệ thống ATS. Viết thư xin việc (Cover Letter) cá nhân hóa cho từng công ty. Thiếu môi trường để luyện tập phỏng vấn và nhận phản hồi khách quan. Giải pháp: AI Career Coach Dự án này giải quyết các vấn đề trên bằng cách sử dụng Amazon Bedrock (Claude 3) để đóng vai trò như một người huấn luyện viên ảo:\nAI Resume Builder: Hỗ trợ viết và chỉnh sửa nội dung CV chuyên nghiệp. Cover Letter Generator: Tự động tạo thư xin việc dựa trên mô tả công việc (JD) và hồ sơ người dùng. Mock Interview: Phỏng vấn thử với AI dựa trên từng ngành nghề cụ thể và chấm điểm câu trả lời. 🛠️ Tech Stack (Công nghệ sử dụng) Dự án này áp dụng mô hình Serverless Microservices, giúp tối ưu chi phí và khả năng mở rộng.\n1. Frontend React (Vite): Tốc độ phát triển nhanh, hiệu năng cao. Tailwind CSS \u0026amp; Shadcn UI: Xây dựng giao diện đẹp, hiện đại và chuẩn accessibility. AWS Amplify: Quản lý Authentication (Cognito) và kết nối API. 2. Backend (Java Serverless) Java 17 \u0026amp; Spring Boot: Nền tảng backend mạnh mẽ. Spring Cloud Function: Chuyển đổi logic Java thành các hàm Serverless. AWS Lambda: Chạy code mà không cần quản lý server. Gồm 5 functions riêng biệt: UserProfileFunction ResumeFunction CoverLetterFunction InterviewFunction IndustryInsightFunction 3. Database \u0026amp; AI Amazon DynamoDB: Cơ sở dữ liệu NoSQL với thiết kế Single Table Design hiệu năng cao. Amazon Bedrock: Cổng kết nối tới các mô hình AI nền tảng (Foundation Models). Chúng ta sử dụng model Claude 3 Haiku của Anthropic. 4. Infrastructure \u0026amp; DevOps AWS SAM (Serverless Application Model): Định nghĩa toàn bộ hạ tầng bằng code (IaC). Amazon S3 \u0026amp; CloudFront: Lưu trữ và phân phối Frontend toàn cầu với bảo mật OAC. 🎯 Mục tiêu Workshop Sau khi hoàn thành workshop này, bạn sẽ nắm được:\nCách xây dựng một ứng dụng Fullstack hoàn chỉnh. Tư duy thiết kế hệ thống Serverless trên AWS. Kỹ thuật Prompt Engineering để tích hợp AI vào ứng dụng Java. Cách bảo mật ứng dụng với JWT và Cognito. Quy trình CI/CD cơ bản: Build, Deploy và Hosting. Nội dung Tổng quan về workshop Chuẩn bị Hạ tầng với SAM Phát triển Backend Phát triển Frontend Deploy Dọn dẹp tài nguyên "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/5-workshop/5.6-deploy/","title":"Deploy","tags":[],"description":"","content":"Chúng ta đã hoàn thành việc viết code (Dev) và thiết kế hạ tầng (Ops). Giờ là lúc kết hợp chúng lại (DevOps) để đưa ứng dụng ra thế giới thực.\nQuy trình triển khai gồm 3 giai đoạn chính:\nBackend Deployment: Đẩy API và Database lên AWS. Frontend Configuration: Cập nhật thông tin kết nối (API URL, Cognito ID) vào code React. Frontend Deployment: Build và đẩy Static Web lên S3. Giai đoạn 1: Triển khai Backend (AWS SAM) Bước 1: Build mã nguồn Java Trước khi deploy, chúng ta cần đóng gói mã nguồn Java thành file .jar có thể chạy được.\nMở Terminal tại thư mục gốc của dự án (nơi có file pom.xml cha hoặc thư mục backend/):\ncd backend mvn clean package -DskipTests Giải thích:\nclean: Xóa các file build cũ. package: Đóng gói thành file JAR (nằm trong target/). -DskipTests: Bỏ qua chạy unit test để tiết kiệm thời gian cho workshop. Bước 2: Deploy lên AWS Quay lại thư mục gốc (nơi chứa template.yaml) và chạy lệnh:\ncd .. sam deploy --guided Làm theo hướng dẫn trên màn hình (chỉ cần Enter để chọn mặc định cho hầu hết các câu hỏi):\nStack Name: career-coach-stack (hoặc tên tùy ý). AWS Region: ap-southeast-1 (Singapore). Confirm changes before deploy: Y. Allow SAM CLI IAM role creation: Y. Save arguments to configuration file: Y. Quá trình này sẽ mất khoảng 5-7 phút để CloudFormation tạo Database, Lambda, API Gateway và CloudFront.\nBước 3: Lưu lại thông tin Output Sau khi deploy thành công, màn hình sẽ hiện ra bảng Outputs. Hãy copy lại các thông số sau vào Notepad, chúng ta sẽ cần chúng ngay lập tức:\nApiEndpoint: URL của API Gateway (Ví dụ: https://xyz.execute-api\u0026hellip;). CognitoUserPoolId: ID của User Pool. CognitoClientId: ID của App Client. S3BucketName: Tên Bucket để chứa web. WebsiteURL: Đường dẫn trang web (CloudFront). Giai đoạn 2: Cấu hình Frontend Frontend cần biết phải gọi API nào và đăng nhập vào đâu.\nBước 1: Cập nhật API Client Mở file frontend/src/lib/api.js:\n// Thay thế bằng ApiEndpoint bạn vừa copy const BASE_URL = \u0026#34;https://xxxxxxxxx.execute-api.ap-southeast-1.amazonaws.com\u0026#34;; Bước 2: Cập nhật Auth Config Mở file frontend/src/main.jsx:\nAmplify.configure({ Auth: { Cognito: { userPoolId: \u0026#39;ap-southeast-1_XXXXXXX\u0026#39;, // Paste CognitoUserPoolId userPoolClientId: \u0026#39;xxxxxxxxxxxxxxxxx\u0026#39;, // Paste CognitoClientId loginWith: { email: true } } } }); Giai đoạn 3: Triển khai Frontend (S3 \u0026amp; CloudFront) Bước 1: Build dự án React (Vite) Chuyển vào thư mục frontend và tiến hành build (biên dịch):\ncd frontend npm run build Kết quả: Một thư mục tên là dist sẽ được tạo ra. Đây là phiên bản \u0026ldquo;tinh gọn\u0026rdquo; của web, đã được tối ưu hóa dung lượng.\nBước 2: Đẩy code lên S3 Sử dụng AWS CLI để đồng bộ thư mục dist lên S3 Bucket (dùng tên bucket bạn đã lưu ở Giai đoạn 1):\naws s3 sync dist s3://career-coach-frontend-123456789 --delete Tham số \u0026ndash;delete: Tự động xóa các file cũ trên S3 nếu trong thư mục dist không còn tồn tại (giúp dọn rác).\nBước 3: Xóa Cache CloudFront (Invalidation) Đây là bước bắt buộc mỗi khi update code frontend. Nếu không làm bước này, người dùng vẫn sẽ thấy phiên bản web cũ do CloudFront lưu cache.\nLấy ID của CloudFront Distribution:\naws cloudfront list-distributions --query \u0026#34;DistributionList.Items[*].{ID:Id, Domain:DomainName}\u0026#34; --output table Chạy lệnh xóa cache:\naws cloudfront create-invalidation --distribution-id \u0026lt;DISTRIBUTION_ID\u0026gt; --paths "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/6-self-evaluation/","title":"Tự đánh giá","tags":[],"description":"","content":"Trong suốt thời gian thực tập tại CÔNG TY TNHH AMAZON WEB SERVICES VIỆT NAM từ 01/09/2025 đến 09/09/2025, tôi đã có cơ hội học hỏi, rèn luyện và áp dụng kiến thức đã được trang bị tại trường vào môi trường làm việc thực tế.\nTôi đã tham gia tìm hiểu và thực hành với các dịch vụ của aws đồng thời tự đề xuất và phát triển dự án AI Career Coach kết hợp với các dịch vụ serverless của aws, qua đó cải thiện kỹ năng lập trình, phân tích, viết báo cáo.\nVề tác phong, tôi luôn cố gắng hoàn thành tốt nhiệm vụ, tuân thủ nội quy, và tích cực trao đổi với đồng nghiệp để nâng cao hiệu quả công việc.\nĐể phản ánh một cách khách quan quá trình thực tập, tôi xin tự đánh giá bản thân dựa trên các tiêu chí dưới đây:\nSTT Tiêu chí Mô tả Tốt Khá Trung bình 1 Kiến thức và kỹ năng chuyên môn Hiểu biết về ngành, áp dụng kiến thức vào thực tế, kỹ năng sử dụng công cụ, chất lượng công việc ✅ ☐ ☐ 2 Khả năng học hỏi Tiếp thu kiến thức mới, học hỏi nhanh ✅ ☐ ☐ 3 Chủ động Tự tìm hiểu, nhận nhiệm vụ mà không chờ chỉ dẫn ✅ ☐ ☐ 4 Tinh thần trách nhiệm Hoàn thành công việc đúng hạn, đảm bảo chất lượng ✅ ☐ ☐ 5 Kỷ luật Tuân thủ giờ giấc, nội quy, quy trình làm việc ✅ ☐ ☐ 6 Tính cầu tiến Sẵn sàng nhận feedback và cải thiện bản thân ☐ ✅ ☐ 7 Giao tiếp Trình bày ý tưởng, báo cáo công việc rõ ràng ☐ ✅ ☐ 8 Hợp tác nhóm Làm việc hiệu quả với đồng nghiệp, tham gia nhóm ☐ ✅ ☐ 9 Ứng xử chuyên nghiệp Tôn trọng đồng nghiệp, đối tác, môi trường làm việc ✅ ☐ ☐ 10 Tư duy giải quyết vấn đề Nhận diện vấn đề, đề xuất giải pháp, sáng tạo ☐ ✅ ☐ 11 Đóng góp vào dự án/tổ chức Hiệu quả công việc, sáng kiến cải tiến, ghi nhận từ team ✅ ☐ ☐ 12 Tổng thể Đánh giá chung về toàn bộ quá trình thực tập ✅ ☐ ☐ Cần cải thiện Cần tập trung diễn đạt ý tưởng và báo cáo công việc một cách mạch lạc, gãy gọn và thuyết phục hơn. Đừng chỉ dừng lại ở việc phát hiện lỗi, hãy rèn luyện khả năng đề xuất các giải pháp sáng tạo và tối ưu hơn cho vấn đề đó. Cần chủ động phối hợp nhịp nhàng hơn với đồng nghiệp và thể hiện thái độ cởi mở, tích cực hơn nữa khi đón nhận feedback. "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/1-worklog/1.6-week6/","title":"Worklog Tuần 6","tags":[],"description":"","content":"Mục tiêu tuần 6: Hiểu quy trình xây dựng AMI, Launch Template và triển khai WordPress trong môi trường có khả năng mở rộng. Sử dụng Lambda Function để tối ưu chi phí, tự động bật/tắt EC2 Instance theo nhu cầu. Làm quen với Grafana để giám sát dữ liệu và hệ thống. Biết cách quản lý tài nguyên bằng Tag, Resource Groups và áp dụng kiểm soát truy cập bằng IAM. Tìm hiểu AWS Systems Manager để chạy lệnh từ xa và quản lý bản vá (Patch Manager). Các công việc cần triển khai trong tuần này: Thứ Công việc Ngày bắt đầu Ngày hoàn thành Nguồn tài liệu 2 - Thực hành: triển khai ứng dụng Wordpress với Auto Scaling Group nhằm đảm bảo khả năng co giãn của ứng dụng đó theo nhu cầu của người truy cập + Chuẩn bị VPC và subnet, tạo Security Group cho EC2, Database và khởi tạo EC2, Database + Cài đặt wordpress trên EC2 + Thực hiện tạo Autoscaling cho wordpress Instance + Khởi tạo AMI từ Webserver Instance + Khởi tạo Launch Template + Khởi tạo Target Group + Khởi tạo Load Balancer + Khởi tạo Auto Scaling Group + Sao lưu và phục hồi database + Khởi tạo Cloudfront cho Web Server 13/10/2025 13/10/2025 cloudjourney.awsstudygroup.com 3 - Tìm hiểu về Lambda function - Thực hành: sử dụng Lambda function để tối ưu hóa chi phí cho hệ thống của bạn trên môi trường AWS + Tạo VPC, Security Group, EC2 + Incoming Web-hooks slack + Tạo tag cho instance + Tạo Role cho Lambda + Tạo Lambda Function thực hiện chức năng Stop instances + Tạo Lambda Function thực hiện chức năng Start instances + Kiểm tra kết quả 14/10/2025 14/10/2025 cloudjourney.awsstudygroup.com 4 - Tìm hiểu về Grafana - Thực hành: + Tạo VPC và Subnet, Security Group, Linux EC2 Instance + Tạo IAM User, IAM Role, gán IAM Role cho EC2 Instance + Cài đặt Grafana + Thực hiện kết nối EC2 bằng MobaXterm + Giám sát với Grafana 15/10/2025 15/10/2025 cloudjourney.awsstudygroup.com và grafana.com/grafana 5 - Tìm hiểu về quản lý tài nguyên bằng Tag và Resource Groups - Thực hành: + Tạo EC2 Instance có tag + Thêm hoặc xóa tag trên các tài nguyên đơn lẻ và trên các nhóm các tài nguyên + Lọc tài nguyên theo tag + Tạo một Resource Group - Thực hành: quản lý truy cập vào dịch vụ EC2 Resource Tag với AWS IAM + Tạo IAM User + Tạo IAM Policy + Tạo IAM Role + Chuyển đổi Role + Kiểm tra IAM Policy + Tiến hành truy cập EC2 console ở AWS Region - Tokyo + Tiến hành truy cập EC2 console ở AWS Region - North Virginia + Tiến hành tạo EC2 instance khi không có và có Tags thỏa điều kiện + Chỉnh sửa Resource Tag trên EC2 Instance + Kiểm tra chính sách 16/10/2025 16/10/2025 cloudjourney.awsstudygroup.com 6 - Tìm hiểu về AWS Systems Manager - Thực hành: quản lý Patch và chạy câu lệnh trên nhiều máy chủ với AWS System Manager + Tạo VPC, Subnet, EC2 Instance, IAM Role và gán IAM Role + Thiết lập Patch Manager + Run Command 17/10/2025 17/10/2025 cloudjourney.awsstudygroup.com Kết quả đạt được tuần 6: Triển khai WordPress theo mô hình mở rộng gồm: tạo VPC/Subnet/SG, cài Webserver, tạo AMI, Launch Template, Target Group, Load Balancer và Auto Scaling Group; đồng thời sao lưu – phục hồi database và cấu hình CloudFront. Xây dựng giải pháp tự động tối ưu chi phí bằng Lambda, gồm tạo Role, gán tag, tạo Lambda Function Stop/Start EC2 và kiểm tra kích hoạt qua Slack Webhook. Triển khai Grafana để giám sát hệ thống, gồm tạo EC2 Linux, IAM User/Role, cài Grafana và kết nối để theo dõi dữ liệu. Quản lý tài nguyên bằng Tag và Resource Groups, đồng thời áp dụng IAM để kiểm soát truy cập theo Tag và thử nghiệm ở nhiều Region. Sử dụng AWS Systems Manager để quản lý bản vá bằng Patch Manager và chạy lệnh từ xa với Run Command. "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/7-feedback/","title":"Chia sẻ, đóng góp ý kiến","tags":[],"description":"","content":"Đánh giá chung 1. Môi trường làm việc\nKhông gian làm việc tại đây rất thoáng đãng và ngăn nắp, tạo cảm giác thoải mái để mình tập trung tối đa. Các thành viên trong FCJ cực kỳ cởi mở, luôn nhiệt tình hỗ trợ nhau ngay cả khi đã hết giờ làm. Tuy nhiên, mình hy vọng chương trình có thể tổ chức thêm các hoạt động giao lưu để mọi người có cơ hội gắn kết và hiểu nhau sâu hơn.\n2. Sự hỗ trợ của mentor / team admin\nMình rất ấn tượng với cách làm việc của Mentor: hướng dẫn tận tâm, giải thích cặn kẽ và luôn khuyến khích tinh thần chủ động đặt câu hỏi. Đặc biệt, thay vì đưa ngay đáp án, Mentor thường gợi mở để mình tự tìm tòi và giải quyết vấn đề. Bên cạnh đó, Team Admin cũng hỗ trợ rất chu đáo về mặt thủ tục, giấy tờ, giúp quá trình thực tập của mình diễn ra suôn sẻ.\n3. Sự phù hợp giữa công việc và chuyên ngành học\nCác đầu việc có tính liên kết chặt chẽ với kiến thức chuyên ngành mình đã học tại trường, đồng thời mở rộng sang nhiều mảng công nghệ mới mà mình chưa có dịp tiếp cận. Nhờ đó, mình vừa có thể hệ thống hóa lại nền tảng lý thuyết, vừa trau dồi thêm được nhiều kỹ năng thực chiến quý báu.\n4. Cơ hội học hỏi \u0026amp; phát triển kỹ năng\nKỳ thực tập đã giúp mình hoàn thiện bộ kỹ năng quan trọng như: sử dụng các tool quản lý dự án, kỹ năng teamwork và tác phong giao tiếp chuyên nghiệp trong doanh nghiệp. Ngoài kiến thức chuyên môn, những chia sẻ về kinh nghiệm thực tế từ Mentor cũng giúp mình định hình rõ ràng hơn con đường sự nghiệp sắp tới.\n5. Văn hóa \u0026amp; tinh thần đồng đội\nVăn hóa công ty mang đến năng lượng rất tích cực: sự tôn trọng luôn được đặt lên hàng đầu, mọi người làm việc nghiêm túc nhưng không khí vẫn vui vẻ. Tinh thần đồng đội thể hiện rõ nhất những lúc chạy dự án gấp, ai cũng sẵn sàng hỗ trợ mà không nề hà vị trí. Điều này khiến mình thực sự cảm thấy được hòa nhập và là một phần của tập thể.\n6. Chính sách / phúc lợi cho thực tập sinh\nCông ty tạo điều kiện rất tốt về sự linh hoạt thời gian khi thực tập sinh có việc cần thiết.\nMột số câu hỏi khác 1. Điều bạn hài lòng nhất trong thời gian thực tập? Điều khiến mình cảm kích nhất chính là sự tận tâm và nhiệt huyết của đội ngũ Mentor và Admin. Các anh chị không chỉ hỗ trợ sát sao khi mình/em gặp khó khăn mà còn cung cấp một kho tài liệu học tập vô cùng phong phú. Chính nguồn tài nguyên chất lượng này đã giúp mình/em có nền tảng vững chắc để triển khai dự án một cách thuận lợi và hiệu quả.\n2. Điều bạn nghĩ công ty cần cải thiện cho các thực tập sinh sau? Mình đề xuất chương trình nên đồng bộ hóa tài liệu hướng dẫn thực tập với lộ trình thi các chứng chỉ AWS tiêu chuẩn. Việc thiết kế flow tài liệu song song với sườn nội dung thi (exam guide) sẽ là một cải tiến lớn, giúp thực tập sinh vừa hoàn thành tốt dự án, vừa đạt được mục tiêu sở hữu chứng chỉ quốc tế ngay khi tốt nghiệp khóa FCJ.\n3. Nếu giới thiệu cho bạn bè, bạn có khuyên họ thực tập ở đây không? Vì sao? Chắc chắn là Có. Đây là môi trường lý tưởng cho bất kỳ ai muốn bắt đầu sự nghiệp trong ngành Cloud Computing. Tại FCJ, bạn bè mình sẽ không chỉ học được kỹ năng cứng về AWS mà còn rèn luyện được tư duy giải quyết vấn đề và phong cách làm việc chuyên nghiệp của một tập đoàn công nghệ toàn cầu.\nĐề xuất \u0026amp; mong muốn 1. Bạn có đề xuất gì để cải thiện trải nghiệm trong kỳ thực tập? Mình đề xuất tổ chức thêm các buổi \u0026lsquo;Tech Sharing\u0026rsquo; hoặc \u0026lsquo;Deep-dive Session\u0026rsquo; nhỏ hàng tuần, nơi các thực tập sinh có thể trình bày về giải pháp mình đang làm để nhận feedback chéo từ các mentor và các team khác. Điều này sẽ giúp tụi mình rèn luyện kỹ năng thuyết trình và nhìn nhận vấn đề đa chiều hơn.\n2. Bạn có muốn tiếp tục chương trình này trong tương lai? Mình rất mong muốn có cơ hội tiếp tục đồng hành cùng công ty. Sau chương trình FCJ, mình hy vọng có thể ứng tuyển vào các vị trí thực tập nâng cao hoặc Fresher để áp dụng những gì đã học vào các dự án thực tế.\n3. Góp ý khác (tự do chia sẻ): Mình xin gửi lời cảm ơn chân thành đến Mentor và các anh chị trong ban quản lý FCJ đã kiên nhẫn hướng dẫn mình trong suốt thời gian qua. Chương trình thực sự là một bước đệm vững chắc (kick-start) cho sự nghiệp của mình. Chúc chương trình FCJ các mùa sau sẽ ngày càng thành công và thu hút thêm nhiều tài năng trẻ.\n"},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/5-workshop/5.7-clean/","title":"Dọn dẹp tài nguyên","tags":[],"description":"","content":"Sau khi hoàn thành workshop, điều cực kỳ quan trọng là bạn phải xóa các tài nguyên đã tạo để tránh bị AWS tính phí \u0026ldquo;oan\u0026rdquo; vào cuối tháng.\nQuy trình dọn dẹp gồm 2 bước chính.\nBước 1: Xóa Frontend Bucket (Bắt buộc) 🗑️ Lệnh sam delete sẽ thất bại khi cố xóa S3 Bucket nếu bucket đó vẫn còn chứa file (code frontend bạn đã upload). Do đó, chúng ta cần xóa bucket này thủ công trước.\nMở Terminal. Chạy lệnh sau để xóa sạch file và xóa luôn bucket (thay tên bucket của bạn vào): aws s3 rb s3://career-coach-frontend-123456789 --force Giải thích:\nrb: Remove Bucket \u0026ndash;force: Ép buộc xóa kể cả khi bucket còn chứa file (nguy hiểm nhưng tiện lợi cho workshop). Bước 2: Xóa Stack Backend (SAM Delete) Sau khi Bucket đã xóa, giờ chúng ta có thể yên tâm xóa toàn bộ hạ tầng còn lại (Lambda, DynamoDB, API Gateway, Cognito\u0026hellip;).\nTại thư mục gốc của dự án (nơi có file template.yaml), chạy lệnh:\nsam delete Xác nhận hành động:\nAre you sure you want to delete the stack [career-coach-stack]? -\u0026gt; Nhập y (Yes). Are you sure you want to delete the folder [career-coach-stack]\u0026hellip;? -\u0026gt; Nhập y. Quá trình này sẽ mất khoảng 2-3 phút. SAM sẽ dọn dẹp sạch sẽ mọi thứ được định nghĩa trong template.yaml.\n"},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/1-worklog/1.7-week7/","title":"Worklog Tuần 7","tags":[],"description":"","content":"Mục tiêu tuần 7: Hiểu và thực hành AWS Systems Manager – Session Manager, gồm kết nối EC2 public/private, thiết lập Endpoint và quản lý session logs. Nắm được các khái niệm và thực hành cơ bản \u0026amp; nâng cao của AWS CloudFormation, bao gồm tạo template, tạo stack, StackSets và Drift Detection. Biết sử dụng AWS Cloud9 để làm việc với CloudFormation và môi trường AWS. Hiểu và thiết lập AWS IAM Identity Center (AWS SSO) trong AWS Organization: Users, Groups, Permission Sets và phân quyền truy cập. Áp dụng Time-based Access Control và Customer Managed Policies để thiết lập các Permission Set nâng cao cho từng nhóm người dùng trong Organization. Các công việc cần triển khai trong tuần này: Thứ Công việc Ngày bắt đầu Ngày hoàn thành Nguồn tài liệu 2 - Tìm hiểu về Session Manager - Thực hành: làm việc với Amazon System Manager - Session Manager + Tạo VPC, Public subnet, Private subnet, security group, máy chủ Linux public và Windows private + Tạo IAM Role + Tạo kết nối đến máy chủ EC2 Public + Tạo kết nối đến máy chủ EC2 Private + Kích hoạt DNS hostnames + Tạo Endpoint ssm + Tạo Endpoint ssmmessages + Tạo Endpoint ec2messages + Gán IAM role và restart EC2 instance + Quản lý session logs + Cập nhật IAM Role + Tạo S3 bucket và S3 Gateway endpoint + Theo dõi session logs + Kiểm tra Session logs trong S3 + Port Forwarding + Tạo IAM User có quyền kết nối SSM + Cài đặt và cấu hình AWS CLI và Session Manager Plugin + Thực hiện Portforwarding 20/10/2025 20/10/2025 cloudjourney.awsstudygroup.com 3 - Tìm hiểu về AWS CloudFormation và AWS Cloud9 - Thực hành: tạo một CloudFormation template và một vài tính năng cơ bản của CloudFormation, và cách kiểm tra template + Tạo IAM User, IAM Role + Tạo Workspace + Tạo CloudFormation Template 21/10/2025 21/10/2025 cloudjourney.awsstudygroup.com, https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/Welcome.html, https://docs.aws.amazon.com/AWSCloudFormation/latest/TemplateReference/aws-template-resource-type-ref.html 4 - Tìm hiểu về StackSets, Drift Detection, Simple Queue Service - Thực hành: CloudFormation nâng cao + Tạo Lambda Function + Tạo Stack trong CloudFormation + Kết nối EC2 Instance + Ánh xạ và Stacksets + Thay đổi cấu hình tài nguyên với Drift 22/10/2025 22/10/2025 cloudjourney.awsstudygroup.com và https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/welcome.html 5 - Thực hành: Thiết lập Single Sign-On (Amazon SSO) cho Organization + Kích hoạt AWS Organizations + Kích hoạt IAM Identity Center + Tạo User và Groups trong IAM Identity Center + Tạo Permission Sets + Cung cấp Permission Sets + Kiểm tra quyền truy cập dựa trên người dùng, nhóm và permission set + Triển khai CloudFormation Template + Xác thực quyền truy cập + Kiểm tra quyền Administrator + Kiểm tra quyền ReadOnly + Cấu hình AWS CLI - Làm mới thông tin xác thực thủ công + Cấu hình AWS CLI - Làm mới thông tin xác thực tự động 23/10/2025 23/10/2025 cloudjourney.awsstudygroup.com 6 - Thực hành: Thiết lập Single Sign-On (Amazon SSO) cho Organization + Sử dụng Time-based access control cung cấp quyền truy cập tạm thời vào AWS accounts cho Security Auditor + Tạo Permission Set với quyền truy cập cần thiết cho Security Auditor dưới dạng inline policy với các điều kiện time-based access control + Tạo Group cho Security Auditors + Gán người dùng vào Group Security Auditors + Gán quyền truy cập vào AWS Account cho nhóm Security Auditors với permission set mới tạo + Tạo CMP, tạo permission set bằng cách gắn CMP đã tạo và cuối cùng là cung cấp permission set cho AWS account + Tạo Customer Managed IAM Policy + Tạo permission Set với Customer Managed policy + Tạo Group và tạo user và thêm vào Group + Gán Permission set cho AWS Account và xác minh quyền truy cập 24/10/2025 24/10/2025 cloudjourney.awsstudygroup.com Kết quả đạt được tuần 7: Làm chủ Session Manager trong AWS Systems Manager: tạo môi trường VPC public/private, gán IAM Role, thiết lập các endpoint SSM, EC2Messages, SSMMessages và kết nối thành công đến cả EC2 Public và Private. Quản lý và theo dõi Session Logs: cấu hình S3 bucket, S3 Gateway Endpoint, cập nhật IAM Role để ghi log và xác minh log hoạt động đúng trong S3. Thực hiện Port Forwarding qua SSM: tạo IAM User, cấu hình AWS CLI + SSM Plugin, thực hiện port forwarding an toàn mà không cần mở port trong Security Group. Tìm hiểu và sử dụng AWS CloudFormation: tạo Workspace Cloud9, tạo IAM User/Role, viết CloudFormation template và kiểm tra tính hợp lệ của template. Triển khai CloudFormation nâng cao: tạo Lambda Function, xây dựng Stack, thiết lập StackSets, ánh xạ tài nguyên, kết nối EC2 và kiểm tra Drift Detection khi thay đổi cấu hình. Thiết lập Single Sign-On với IAM Identity Center cho toàn bộ AWS Organization: tạo Users/Groups, Permission Sets, cấp quyền Administrator/ReadOnly và xác thực quyền theo từng user/group. Cấu hình AWS CLI với IAM Identity Center: thử nghiệm làm mới thông tin đăng nhập thủ công và tự động, đảm bảo nhận diện đúng permission set. Áp dụng Time-based Access Control để cấp quyền truy cập tạm thời cho Security Auditor: tạo Permission Set có điều kiện theo thời gian, phân nhóm Security Auditor, gán quyền và xác thực hoạt động đúng. Tạo Customer Managed Policy (CMP) và kết hợp CMP vào Permission Set, gán cho AWS Account và kiểm tra quyền truy cập thực tế của user. "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/1-worklog/1.8-week8/","title":"Worklog Tuần 8","tags":[],"description":"","content":"Mục tiêu tuần 8: Hiểu và thực hành quản lý danh tính với IAM Identity Center và các API User/Group. Nắm được cơ chế giới hạn quyền bằng IAM Permission Boundary và điều kiện khi chuyển Role (Role Switching). Làm quen với các dịch vụ bảo mật: Security Hub, AWS WAF và các tiêu chuẩn đánh giá an ninh. Tìm hiểu các dịch vụ giám sát – nhật ký – mã hóa như CloudTrail, KMS và Athena. Biết cách sử dụng AWS Backup và SNS để xây dựng quy trình sao lưu và gửi thông báo. Các công việc cần triển khai trong tuần này: Thứ Công việc Ngày bắt đầu Ngày hoàn thành Nguồn tài liệu 2 - Thực hành: IAM Identity Center Identity Store APIs + Environment Setup + Test Setup + Use case Prerequisites + AWS IAM Identity Center User and Group API Operations + Create User and add to the group + Update User’s Group Membership + AWS IAM Identity Center User and Group Audit Operations - Dịch Blog: + Announcing Amazon Quick Suite: your agentic teammate for answering questions and taking action + AWS Transfer Family SFTP connectors now support VPC-based connectivity + AWS Weekly Roundup: Amazon Quick Suite, Amazon EC2, Amazon EKS, and more (October 13, 2025) 27/10/2025 27/10/2025 https://cloudjourney.awsstudygroup.com/ và https://aws.amazon.com/vi/blogs/aws/reimagine-the-way-you-work-with-ai-agents-in-amazon-quick-suite/#:~:text=Today%2C%20we%E2%80%99re%20announcing%20Amazon%20Quick%20Suite%2C%20a%20new,and%20turns%20those%20insights%20into%20actions%20for%20you. và https://aws.amazon.com/vi/blogs/aws/aws-transfer-family-sftp-connectors-now-support-vpc-based-connectivity/ và https://aws.amazon.com/vi/blogs/aws/aws-weekly-roundup-amazon-quick-suite-amazon-ec2-amazon-eks-and-more-october-13-2025/ 3 - Tìm hiểu về IAM Permission Boundary - Thực hành: Giới hạn Quyền của User với IAM Permission Boundary + Tạo Policy Giới hạn + Tạo IAM User Giới Hạn + Kiểm tra xem liệu user được gán quyền có bị giới hạn quyền bởi Permission Boundary - Thực hành: Giới hạn chuyển Role theo Condition + Tạo IAM Group + Tạo các IAM User và kiểm tra quyền của chúng + Cấu hình Role Condition + Tạo IAM Role có quyền Quản trị + Cấu hình Switch role cho IAM User + Giới hạn Thời gian được phép Switch role + Giới hạn IP được phép Switch role 28/10/2025 28/10/2025 https://cloudjourney.awsstudygroup.com/ 4 - Tìm hiểu về AWS Security Hub, các tiêu chuẩn bảo mật - Thực hành: Kích hoạt Security Hub thông qua console - Thực hành: Kiểm tra đánh giá theo từng bộ tiêu chuẩn - Tìm hiểu về AWS Web Application Firewall - Thực hành: thực hiện tạo môi trường cho workshop bao gồm việc tạo S3 bucket và triển khai một Ứng dụng mẫu + Tạo S3 bucket + Triển khai một Ứng dụng OWASP Juice Shop - Thực hành: Sử dụng AWS WAF + Triển khai Web ACLs với managed rules + Tạo Custom Rule + Định nghĩa WAF rule ở định dạng JSON. Các logic phức tạp cần phải được định nghĩa sử dụng các toán tử AND, OR và NOT + Kiểm thử Rule mới + Ghi nhật ký request 29/10/2025 29/10/2025 https://cloudjourney.awsstudygroup.com/ và https://aws.amazon.com/vi/waf/ 5 - Tìm hiểu về AWS Key Management Service, AWS CloudTrail, Amazon Athena - Thực hành: Quản lý Khóa với dịch vụ Key Management Service (AWS KMS) + Tạo Policy, Role, Group và User + Tạo KMS + Tạo Bucket và tải dữ liệu lên S3 + Tạo CloudTrail và ghi nhật ký vào CloudTrail + Tạo Amazon Athena và truy xuất dữ liệu với Athena + Kiểm thử và chia sẻ dữ liệu mã hóa trên S3 30/10/2025 30/10/2025 https://cloudjourney.awsstudygroup.com/ và https://docs.aws.amazon.com/kms/latest/developerguide/overview.html và https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-user-guide.html và https://docs.aws.amazon.com/athena/latest/ug/what-is.html 6 - Tìm hiểu về AWS Backup, AWS Simple Notification Service - Thực hành: Triển khai kế hoạch sao lưu hệ thống với AWS Backup + Tạo S3 bucket + Sử dụng AWS Backup để tạo ra một kế hoạch sao lưu (backup plan) cho các tài nguyên đang hoạt động trên AWS + Tạo Backup Plan + Sử dụng dịch vụ AWS SNS (Simple Notification Service) để gửi thông báo liên quan đến các hoạt động sao lưu đang diễn ra + Kiểm tra hoạt động sao lưu 31/10/2025 31/10/2025 https://cloudjourney.awsstudygroup.com/ và https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html và https://aws.amazon.com/vi/sns/ Kết quả đạt được tuần 8: Quản lý người dùng tập trung bằng IAM Identity Center: thiết lập environment, tạo user/group, cập nhật quyền và thực hiện các thao tác audit qua API. Tăng cường kiểm soát quyền truy cập bằng Permission Boundary và Role Condition: giới hạn quyền user, giới hạn switch role theo thời gian/IP và thử nghiệm phân quyền thực tế. Triển khai các giải pháp bảo mật lớp ứng dụng: kích hoạt Security Hub, đánh giá theo tiêu chuẩn bảo mật; triển khai AWS WAF với managed rules, custom rules, JSON rule logic và ghi nhật ký request. Quản lý mã hóa, theo dõi và phân tích log: tạo KMS key, cấu hình CloudTrail, upload dữ liệu S3, truy vấn log bằng Athena và kiểm thử chia sẻ dữ liệu mã hóa. Thiết lập quy trình sao lưu hệ thống với AWS Backup: tạo backup plan, cấu hình tài nguyên sao lưu, kết hợp SNS để gửi thông báo và kiểm tra kết quả sao lưu. "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/1-worklog/1.9-week9/","title":"Worklog Tuần 9","tags":[],"description":"","content":"Mục tiêu tuần 9: Hiểu và thực hành kết nối nhiều VPC bằng VPC Peering và Transit Gateway. Nắm được quy trình triển khai ứng dụng container: build, push image lên Amazon ECR, chạy bằng Docker, Docker Compose và triển khai bằng Amazon ECS. Làm quen với hệ thống CI/CD sử dụng GitLab CI, GitHub Actions, CodeBuild và CodePipeline. Quản lý và tự động hóa triển khai ứng dụng với CodeCommit – CodeDeploy – CodePipeline, kết hợp CloudWatch Events. Tìm hiểu và cấu hình AWS Storage Gateway và nền tảng lưu trữ Windows Multi-AZ (file system, file share, hiệu suất, quota, deduplication). Các công việc cần triển khai trong tuần này: Thứ Công việc Ngày bắt đầu Ngày hoàn thành Nguồn tài liệu 2 - Tìm hiểu về VPC Peering - Thực hành: Liên kết các Virtual Private Cloud (VPC) với VPC Peering + Khởi tạo CloudFormation Templates + Tạo Security Group và EC2 instance + Cập nhật Network ACL + Tạo kết nối Peering + Kích hoạt Cross-Peer DNS - Tìm hiểu về AWS Transit Gateway - Thực hành: Quản lý tập trung các kết nối với AWS Transit Gateway + Tạo Key Pair và khởi tạo CloudFormation Template + Tạo một AWS Transit Gateway để làm hub trung tâm kết nối các VPC + Cấu hình các Transit Gateway Attachments để kết nối các VPC với Transit Gateway đã tạo + Tạo và cấu hình Route Table cho Transit Gateway để quản lý luồng traffic giữa các VPC + Cấu hình Route Table cho từng VPC để định tuyến traffic thông qua Transit Gateway 03/11/2025 03/11/2025 https://cloudjourney.awsstudygroup.com/ và https://docs.aws.amazon.com/vpc/latest/peering/what-is-vpc-peering.html và https://docs.aws.amazon.com/vpc/latest/tgw/what-is-transit-gateway.html 3 - Tìm hiểu về Amazon ECR, Amazon ECS, Cloud Map - Thực hành: triển khai ứng dụng trên Docker sử dụng các dịch vụ AWS như EC2, RDS, và Amazon ECR + Triển khai một ứng dụng mẫu ở trên chính máy vi tính cá nhân để quan sát và đánh giá + Cấu hình VPC, tạo Security Group, cấu hình Role cho ECR, đăng nhập vào Docker Hub + Tạo DB Subnet Group và khởi chạy RDS Instance + Khởi chạy EC2 Instance, cài đặt các thư viện yêu cầu của ứng dụng và thêm cơ sở dữ liệu để thử nghiệm + Triển khai trên Docker Image + Triển khai với Docker Compose + Push Docker Image lên Amazon ECR + Push Docker Image lên Docker Hub - Thực hành: Triển khai Ứng dụng lên Amazon Elastic Container Service (Amazon ECS) + Dùng kết quả từ Thực hành: triển khai ứng dụng trên Docker sử dụng các dịch vụ AWS như EC2, RDS, và Amazon ECR + Tạo CodeDeploy role và thêm Subnet + Cấu hình NAT gateway, Route Table, Security Group + Tạo namespace trong Cloud Map + Tạo ECS Cluster + Tạo ECS Task Definition cho Frontend và Backend + Tạo Target Group và cấu hình Application Load Balancer + Triển khai Blue/Green và Service Scaling với Backend + Triển khai Rolling với Frontend 04/11/2025 04/11/2025 https://cloudjourney.awsstudygroup.com/ và https://aws.amazon.com/vi/ecr/ và https://docs.aws.amazon.com/AmazonECS/latest/developerguide/Welcome.html và https://docs.amazonaws.cn/en_us/cloud-map/latest/dg/what-is-cloud-map.html 4 - Tìm hiểu về AWS CodePipeline, AWS CodeBuild - Thực hành: Triển khai Ứng dụng với AWS CodePipeline + Triển khai CI/CD với Gitlab • Fork và Chỉnh sửa Code • Cài đặt Gitlab và Runner • Chỉnh sửa và Thêm Role • Tạo Tag và Theo dõi Pipeline • Kiểm tra Kết quả + Triển khai CI/CD với Github Action • Clone template Github • Tạo mới một project và push code lên Github • Tạo Access key và Secret key trong AWS IAM • Kiểm tra Kết quả + Triển khai CI/CD với CodeBuild • Fork github repository • Tạo CodeBuild Frontend • Tạo CodeBuild Backend • Tạo tag cho Repository • Kiểm tra kết quả - Theo dõi ứng dụng với Container Insights (CloudWatch) - Định tuyến logs với Firelens + Tạo S3 Bucket và IAM Role cho Task + Triển khai Service với Task Definition mới + Kiểm tra kết quả 05/11/2025 05/11/2025 https://cloudjourney.awsstudygroup.com/ và https://aws.amazon.com/vi/codepipeline/ và https://docs.aws.amazon.com/codebuild/latest/userguide/welcome.html 5 - Tìm hiểu về AWS CodeCommit, AWS CodeDeploy, AWS CloudWatch Events - Thực hành: Tự động hóa Triển khai Ứng dụng AWS CodePipeline + Dùng kết quả từ Thực hành: triển khai ứng dụng trên Docker sử dụng các dịch vụ AWS như EC2, RDS, và Amazon ECR + Tạo S3 bucket, Git credentials, Git connection, Service role cho CodeDeploy, IAM user, instance profile cho Amazon EC2 instance và gán role cho EC2 instance + Cài đặt CodeDeploy Agent + AWS CodeCommit để đẩy code lên từ máy local + Build project với CodeBuild + Deployment với AWS CodeDeploy + Sử dụng AWS CodePipeline để tạo quá trình CI/CD triển khai ứng dụng - Tìm hiểu về AWS Storage Gateway - Thực hành: Sử dụng AWS Storage Gateway + Tạo Storage Gateway + Tạo File Share + Kết nối File shares trên máy On-premise 06/11/2025 06/11/2025 https://cloudjourney.awsstudygroup.com/ và https://docs.aws.amazon.com/whitepapers/latest/introduction-devops-aws/cloudwatch-events.html và https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html và https://docs.aws.amazon.com/codedeploy/latest/userguide/welcome.html và https://docs.aws.amazon.com/storagegateway/ 6 - Thực hành: Thiết lập hệ thống lưu trữ dữ liệu chung cho hạ tầng Windows. + Tạo môi trường thực hành + Tạo một SSD Multi-AZ file system + Tạo một HDD Multi-AZ file system + Tạo file share + Kiểm tra hiệu năng của STG326 - SAZ. + Theo dõi hiệu suất của STG326 - SAZ + Kích hoạt chống dữ liệu trùng lặp + Kích hoạt shadow copies + Quản lý Session người dùng và mở tệp + Kích hoạt hạn ngạch bộ nhớ của người dùng + Kích hoạt chia sẻ Truy cập liên tục + Mở rộng khả năng thông lượng + Mở rộng dung lượng lưu trữ 07/11/2025 07/11/2025 https://cloudjourney.awsstudygroup.com/ Kết quả đạt được tuần 9: Thiết lập kết nối mạng giữa các VPC bằng VPC Peering và Transit Gateway: tạo CloudFormation, cấu hình Security Group, NACL, Route Tables, Transit Gateway Attachments và Cross-Peer DNS. Triển khai ứng dụng container hóa: build và chạy ứng dụng qua Docker, Docker Compose; tạo RDS, EC2, ECR repo; push image lên ECR và Docker Hub; triển khai lên ECS với Cloud Map, ALB, Blue/Green và Rolling update. Xây dựng quy trình CI/CD với GitLab, GitHub Actions và AWS CodeBuild: cấu hình Runner, Credential, tạo pipeline, build frontend/backend và theo dõi kết quả. Tự động hóa triển khai bằng CodeCommit – CodeBuild – CodeDeploy – CodePipeline: tạo IAM Role, Agent, S3 bucket, Git connection; build và deploy tự động qua pipeline; định tuyến logs bằng FireLens. Thiết lập hệ thống lưu trữ doanh nghiệp: tạo Storage Gateway, File Share; cấu hình hệ thống Windows Multi-AZ file system; theo dõi hiệu năng, bật deduplication, shadow copies, quản lý session và mở rộng dung lượng. "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/1-worklog/1.10-week10/","title":"Worklog Tuần 10","tags":[],"description":"","content":"Mục tiêu tuần 10: Hiểu và thực hành toàn diện Amazon DynamoDB: tạo bảng, đọc–ghi dữ liệu, query, scan, index, backup/restore và giao tiếp qua AWS CLI. Nắm các mô hình nâng cao của DynamoDB như: Global Secondary Index, Sparse Index, Write Sharding, Sequential \u0026amp; Parallel Scan, Streams \u0026amp; Lambda, Adjacency Lists, Composite Keys. Tìm hiểu các giải pháp serverless và event-driven dựa trên DynamoDB như: Global Tables, DynamoDB Streams, Lambda Trigger, Zero-ETL Pipeline với OpenSearch \u0026amp; Bedrock. Nắm vững AWS Cost Optimization: Savings Plans, Reserved Instances, EC2 Rightsizing, Cost Explorer, Glue + Athena để phân tích chi phí nâng cao. Thực hành triển khai ứng dụng TravelBuddy lên Elastic Beanstalk và cấu hình tự động triển khai qua CodeStar, CodeCommit, CodeDeploy. Các công việc cần triển khai trong tuần này: Thứ Công việc Ngày bắt đầu Ngày hoàn thành Nguồn tài liệu 2 - Tìm hiểu về DynamoDB - Thực hành: sử dụng DynamoDB + Khởi động stack CloudFormation + Tạo DynamoDB Tables + Tải Data mẫu - Thực hành: Khám phá DynamoDB với CLI và console + Đọc dữ liệu mẫu + Đọc Item Collections sử dụng Query + Làm việc với Table Scans + Thêm/Sửa dữ liệu + Xóa Data + Transactions + Global Secondary Indexes - Thực hành: Sao lưu với Amazon DynamoDB + Khôi phục theo thời gian của DynamoDB + Sao lưu theo yêu cầu + Sao lưu theo lịch + Hạn chế xóa sao lưu - Thực hành: LMIG: Relational Modeling \u0026amp; Migration + Định cấu hình môi trường MySQL + Tạo tài nguyên DMS + Explore Source Model + Explore Target Model + Load DynamoDB Table + Access DynamoDB Table - Thực hành: LBED: Generative AI với tích hợp DynamoDB zero-ETL vào OpenSearch và Amazon Bedrock + Định cấu hình quyền OpenSearch Service + Kích hoạt mô hình Amazon Bedrock + Tải DynamoDB Data + Cấu hình các kết nối ML và Pipeline trong OpenSearch Service + Tạo Zero-ETL Pipeline + Truy vấn và kết luận 10/11/2025 10/11/2025 https://cloudjourney.awsstudygroup.com/ và https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html và https://www.youtube.com/watch?v=xfxBhvGpoa0 3 - Thực hành: LADV: Advanced Design Patterns for Amazon DynamoDB + Bài tập 1: DynamoDB Capacity Units và Partitioning • Tạo DynamoDB table • Tải mẫu data vào bảng • Tải tệp lớn hơn để so sánh thời gian thực thi • Xem số liệu CloudWatch trên table của bạn • Tăng dung lượng của bảng • Sau khi tăng dung lượng của bảng, tải thêm dữ liệu • Tạo bảng mới với global secondary index dung lượng thấp + Bài tập 2: Sequential và Parallel Table Scans • Thực hiện quét tuần tự • Thực hiện quét song song + Bài tập 3: Global Secondary Index Write Sharding • Tạo GSI • Truy vấn GSI bằng các phân đoạn + Bài tập 4: Global Secondary Index Quá tải • Tạo bảng employees cho global secondary index key quá tải • Tải dữ liệu vào bảng mới • Truy vấn bảng nhân viên bằng cách sử dụng global secondary index với các thuộc tính quá tải + Bài tập 5: Sparse Global Secondary Indexes • Thêm global secondary index mới vào bảng nhân viên • Quét bảng nhân viên để tìm người quản lý mà không cần sử dụng sparse global secondary index • Quét bảng employees để tìm người quản lý bằng cách sử dụng sparse global secondary index - Bài tập 6: Composite Keys + Tạo global secondary index mới cho City-Department + Truy vấn tất cả nhân viên từ tiểu bang (state) + Truy vấn tất cả nhân viên của một thành phố (city) + Truy vấn tất cả nhân viên của một thành phố (city) và phòng ban (department) cụ thể - Bài tập 7: Adjacency Lists + Tạo và tải bảng InvoiceandBilling + Xem lại bảng InvoiceAndBills trên DynamoDB console + Truy vấn chi tiết hóa đơn + Truy vấn chi tiết khách hàng và hóa đơn bằng Index - Bài tập 8: Amazon DynamoDB Streams và Lambda + Tạo bảng bản sao + Xem lại chính sách IAM cho role + Tạo hàm Lambda + Bật DynamoDB Stream + Ánh xạ stream nguồn tới Lambda + Điền vào bảng logfile và xác minh sao chép sang logfile_replica - Thực hành: LCDC: Change Data Capture for Amazon DynamoDB Bắt đầu • Cloud9 • EC2 Instance Tổng quan kịch bản • Tạo bảng DynamoDB • Tải dữ liệu mẫu Cập nhật IAM Role • Bật DynamoDB Stream • Tạo Dead Letter Queue • Tạo Lambda Function • Mô phỏng cập nhật đơn hàng Thay đổi CDC bằng Kinesis Data Streams • Bật Kinesis Data Stream • Tạo DLQ • Tạo Lambda • Cấu hình Lambda • Mô phỏng cập nhật đơn hàng 11/11/2025 11/11/2025 https://cloudjourney.awsstudygroup.com/ 4 - Thực hành: LMR: Xây dựng và triển khai ứng dụng serverless toàn cầu với DynamoDB Bắt đầu Khám phá Global Tables Tương tác với Globalflix UI Thảo luận Global Tables Tóm tắt - Thực hành: LEDA: Kiến trúc Serverless Event Driven với DynamoDB Chuẩn bị Tổng quan Lab 1: Pipeline Deep Dive • Kết nối pipeline • Kết nối StateLambda • Kiểm tra MapLambda trigger • Kết nối ReduceLambda Lab 2: Fault Tolerance \u0026amp; Exactly-Once Processing • Ngăn trùng lặp tại StateLambda • Đảm bảo idempotency tại ReduceLambda Tóm tắt 12/11/2025 12/11/2025 https://cloudjourney.awsstudygroup.com/ 5 - Tìm hiểu Savings Plan và Reserved Instances, CloudWatch - Thực hành: EC2 Rightsizing \u0026amp; Compute Optimizer + Tạo IAM Role cho CloudWatch Agent + Gắn IAM Role vào EC2 instance + Cài CloudWatch Agent Bucket + Cập nhật Resource Optimization + Best Practices cho EC2 sizing + Tối ưu VM theo Compute Optimizer - Thực hành: Trực quan hóa chi phí AWS + Xem chi phí theo dịch vụ + Xem chi phí theo tài khoản + Xem phạm vi Savings Plan + Xem độ co giãn + Xem phạm vi Reserved Instance + Tạo báo cáo EC2 tùy chỉnh + Phân tích chi phí bằng Cost Explorer + Tổng quan Data Transfer Out trong các kiến trúc phổ biến - Tìm hiểu AWS Glue - Thực hành: Phân tích chi phí nâng cao với Glue + Athena + Chuẩn bị, xây dựng DB + Nghiên cứu dữ liệu trong bảng + Tagging \u0026amp; Cost Allocation + Savings Plan, RI, On-demand, Spot Usage 13/11/2025 13/11/2025 https://cloudjourney.awsstudygroup.com/ và https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html và https://docs.aws.amazon.com/glue/latest/dg/what-is-glue.html 6 - Thực hành: Triển khai ứng dụng TravelBuddy lên AWS + Tạo Key Pair, CloudFormation stack + Kết nối Windows instance, cài RDS + Kiểm tra local bằng Eclipse IDE + Triển khai Elastic Beanstalk + Cập nhật ứng dụng + Truy vấn API trong Eclipse IDE - Thực hành: Cấu hình tự động phát hành ứng dụng + CloudFormation template + Tạo AWS CodeStar project + Kết nối Eclipse IDE với CodeCommit + Cập nhật mã nguồn và ghi đè trang mẫu bằng TravelBuddy + Commit thay đổi để kích hoạt triển khai Elastic Beanstalk + Sử dụng AWS CodeDeploy để đẩy Windows Service lên EC2 + Giám sát dịch vụ 14/11/2025 14/11/2025 https://cloudjourney.awsstudygroup.com/ Kết quả đạt được tuần 10: Học DynamoDB từ cơ bản đến nâng cao: tạo bảng, tải dữ liệu mẫu, CRUD qua CLI/Console, Query/Scan, Transactions, Item Collections và Global Secondary Index. Triển khai đầy đủ cơ chế sao lưu DynamoDB: PITR, backup on-demand, scheduled backup và hạn chế xóa bản sao lưu. Áp dụng các mô hình thiết kế nâng cao: Capacity Units, Partitioning, Sequential/Parallel Scan, Write Sharding, xử lý GSI quá tải, Sparse Index, Composite Keys và Adjacency Lists. Tích hợp DynamoDB Streams với Lambda để sao chép dữ liệu sang bảng replica; cấu hình IAM; tạo trigger và xác minh replication. Xây dựng kiến trúc Serverless \u0026amp; Event-Driven: Global Tables, Globalflix lab, pipeline StateLambda → MapLambda → ReduceLambda với idempotency và chống trùng lặp; Zero-ETL DynamoDB – OpenSearch – Bedrock. Tối ưu chi phí AWS: Savings Plan, RI, Rightsizing, Compute Optimizer, Cost Explorer, phân tích Data Transfer Out, Glue + Athena để truy vấn chi phí nâng cao. Triển khai TravelBuddy: cài đặt môi trường, deploy Elastic Beanstalk, cập nhật, kết nối CI/CD (CodeStar → CodeCommit → CodeDeploy), đẩy Windows Service và giám sát dịch vụ. "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/1-worklog/1.11-week11/","title":"Worklog Tuần 11","tags":[],"description":"","content":"Mục tiêu tuần 11: Hoàn thiện thiết kế kiến trúc hệ thống Serverless trên AWS (S3, CloudFront, API Gateway, Lambda, DynamoDB). Thiết kế cơ sở dữ liệu DynamoDB theo mô hình Single Table Design (Access Patterns, PK/SK Design). Thiết kế giao diện (UI/UX) cho các trang chức năng chính: Dashboard, Resume Builder, Mock Interview. Khởi tạo cấu trúc dự án Monorepo (Backend Java Spring Cloud \u0026amp; Frontend React Vite). Thiết lập Infrastructure as Code (IaC) với AWS SAM (template.yaml) và cấu hình quyền IAM/Bedrock. Các công việc cần triển khai trong tuần này: Thứ Công việc Ngày bắt đầu Ngày hoàn thành Nguồn tài liệu 2 - Vẽ sơ đồ luồng dữ liệu (Data Flow): User -\u0026gt; CloudFront -\u0026gt; API Gateway -\u0026gt; Lambda.\n- Xác định các dịch vụ AWS cần thiết: Bedrock (Claude 3), Cognito, DynamoDB.\n- Phân tích yêu cầu nghiệp vụ cho 4 module chính: Resume, Cover Letter, Interview, Industry Insight.\n- Lên danh sách các API Endpoints cần thiết. 17/11/2025 17/11/2025 3 - Định nghĩa các Entity: User, Resume, Assessment, CoverLetter.\n- Xác định Access Patterns (Cách query dữ liệu).\n- Thiết kế Partition Key (PK) và Sort Key (SK) cho từng Entity (VD: USER#{id}, METADATA, RESUME, LETTER#uuid).\n- Thiết kế Global Secondary Index (GSI) nếu cần. 18/11/2025 18/11/2025 4 - Thiết kế luồng đăng nhập/đăng ký với Cognito.\n- Phác thảo giao diện Dashboard thống kê.\n- Thiết kế giao diện Resume Builder (chia đôi màn hình: Form \u0026amp; Preview).\n- Thiết kế giao diện Mock Interview (Quiz form).\n- Lựa chọn bộ thư viện UI: Tailwind CSS, Shadcn UI, Lucide Icons. 19/11/2025 19/11/2025 5 - Cài đặt môi trường: Java 17, Maven, Node.js, AWS CLI, SAM CLI.\n- Khởi tạo cấu trúc Backend: Spring Boot 3 + Spring Cloud Function.\n- Khởi tạo cấu trúc Frontend: React + Vite.\n- Cấu hình Git Repository và cấu trúc thư mục Monorepo. 20/11/2025 20/11/2025 6 - Tạo file template.yaml.\n- Khai báo tài nguyên DynamoDB Table (PAY_PER_REQUEST).\n- Khai báo Cognito User Pool \u0026amp; Client.\n- Khai báo S3 Bucket \u0026amp; CloudFront Origin Access Control (OAC).\n- Cấu hình IAM Policies cho Lambda (quyền gọi Bedrock \u0026amp; DynamoDB).\n- Đăng ký Model Access (Claude 3 Haiku) trên AWS Bedrock. 21/11/2025 21/11/2025 Kết quả đạt được tuần 11: Bản thiết kế kiến trúc hệ thống Serverless hoàn chỉnh. Schema thiết kế DynamoDB Single Table sẵn sàng cho việc code. Môi trường phát triển (Dev Environment) đã được cài đặt đầy đủ. File template.yaml của AWS SAM đã sẵn sàng để deploy hạ tầng cơ bản. Quyền truy cập model AI Claude 3 trên AWS Bedrock đã được kích hoạt. "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/1-worklog/1.12-week12/","title":"Worklog Tuần 12","tags":[],"description":"","content":"Mục tiêu tuần 12: Xây dựng hoàn thiện 5 Lambda Functions sử dụng Java Spring Cloud Function. Triển khai tầng Repository tương tác với DynamoDB (Enhanced Client). Tích hợp AWS SDK v2 để gọi Amazon Bedrock (Claude 3 Haiku) cho các tính năng AI. Xử lý các vấn đề kỹ thuật chuyên sâu: Prompt Engineering, JSON Serialization (ObjectMapper), Error Handling. Deploy Backend lên AWS và kiểm thử API qua Postman. Các công việc cần triển khai trong tuần này: Thứ Công việc Ngày bắt đầu Ngày hoàn thành Nguồn tài liệu 2 - Tạo UserEntity \u0026amp; UserRepository.\n- Viết logic CRUD thông tin người dùng.\n- Tích hợp logic xác thực JWT từ Cognito trong Lambda.\n- Xử lý logic Onboarding cho người dùng mới.\n- Deploy thử nghiệm Lambda đầu tiên với SAM. 24/11/2025 24/11/2025 3 - Tạo ResumeEntity \u0026amp; ResumeRepository.\n- Viết logic lưu/lấy nội dung Markdown từ DynamoDB.\n- Cấu hình ObjectMapper thủ công để xử lý lỗi JSON Serialization (tránh lỗi object rỗng).\n- Viết Unit Test cho tầng Service. 25/11/2025 25/11/2025 4 - Cấu hình BedrockRuntimeClient trong Java.\n- Viết Service improveWithAI: Gửi text thô -\u0026gt; Nhận text đã sửa.\n- Thực hiện Prompt Engineering để tối ưu kết quả từ Claude 3.\n- Xử lý Exception và Timeout khi gọi AI. 26/11/2025 26/11/2025 5 - CoverLetter: Viết Prompt tạo thư xin việc dựa trên JD và Profile.\n- Interview: Viết logic sinh câu hỏi trắc nghiệm (Generate Quiz).\n- Interview: Xử lý Prompt để bắt AI trả về đúng định dạng JSON Array.\n- Interview: Viết logic lưu điểm số (Save Result) vào DynamoDB. 27/11/2025 27/11/2025 6 - Xây dựng IndustryInsightFunction (Optional - Cache strategy).\n- Review và Refactor code (Clean Code).\n- Build toàn bộ project (mvn clean package).\n- Chạy sam deploy để đẩy toàn bộ Backend lên AWS.\n- Test toàn bộ API Endpoints bằng Postman/Curl. 28/11/2025 28/11/2025 Kết quả đạt được tuần 12: 5 Lambda Functions hoạt động ổn định trên AWS. API Gateway đã public các endpoints cần thiết. Tích hợp thành công Amazon Bedrock để sinh nội dung CV, Cover Letter và Quiz. Dữ liệu được lưu trữ và truy xuất chính xác từ DynamoDB. Khắc phục được các lỗi liên quan đến JSON Serialization trong môi trường Serverless. "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/1-worklog/1.13-week13/","title":"Worklog Tuần 13","tags":[],"description":"","content":"Mục tiêu tuần 13: Xây dựng Frontend React hoàn chỉnh với Vite, Tailwind CSS và Shadcn UI. Tích hợp AWS Amplify để xử lý Đăng nhập/Đăng ký. Kết nối Frontend với Backend API Gateway (Integration). Hoàn thiện các tính năng cốt lõi: Resume Builder, Quiz Game, Dashboard. Build, Deploy Frontend lên S3/CloudFront và kiểm thử toàn hệ thống (UAT). Các công việc cần triển khai trong tuần này: Thứ Công việc Ngày bắt đầu Ngày hoàn thành Nguồn tài liệu 2 - Cài đặt Tailwind CSS, Shadcn UI components (Button, Card, Input\u0026hellip;).\n- Cấu hình AWS Amplify (Amplify.configure) với UserPoolId từ Backend.\n- Tạo trang Login/Register sử dụng component Authenticator.\n- Tạo Layout chính (Sidebar, Header, Protected Routes). 01/12/2025 01/12/2025 Tài liệu AWS Amplify UI 3 - Code trang Dashboard: Fetch data lịch sử và hiển thị thống kê.\n- Code trang Resume Builder: Tích hợp Markdown Editor (@uiw/react-md-editor).\n- Xây dựng Form nhập liệu CV với React Hook Form \u0026amp; Zod Validation.\n- Tích hợp tính năng xuất PDF (html2pdf.js). 02/12/2025 02/12/2025 Tài liệu React Hook Form 4 - Viết apiClient wrapper: Tự động gắn Token và xử lý \u0026ldquo;Double JSON parsing\u0026rdquo;.\n- Kết nối nút \u0026ldquo;Improve with AI\u0026rdquo; trong Resume Builder với API Backend.\n- Xây dựng giao diện Cover Letter Generator: Form nhập JD -\u0026gt; Hiển thị kết quả AI.\n- Xử lý loading state (Skeleton/Spinner) khi chờ AI trả lời. 03/12/2025 03/12/2025 5 - Code giao diện làm bài trắc nghiệm (Radio buttons).\n- Xử lý logic tính điểm và hiển thị kết quả đúng/sai (Logic so sánh chuỗi).\n- Vẽ biểu đồ tiến độ (Performance Chart) dùng Recharts.\n- Review giao diện tổng thể, fix lỗi CSS, Responsive Mobile. 04/12/2025 04/12/2025 6 - Chạy npm run build để đóng gói Frontend.\n- Đồng bộ code lên S3 (aws s3 sync).\n- Invalidate Cache CloudFront để cập nhật code mới nhất.\n- Kiểm thử luồng đi trọn vẹn (End-to-End Testing) trên môi trường Production. 05/12/2025 05/12/2025 Kết quả đạt được tuần 13: Website AI Career Coach hoàn chỉnh, hoạt động mượt mà trên môi trường Internet. Người dùng có thể đăng nhập, tạo CV, viết Cover Letter và luyện phỏng vấn. Frontend kết nối thành công với Backend Serverless và AI Bedrock. Hệ thống được triển khai tự động hóa một phần qua CLI. Sẵn sàng cho việc demo. "},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://duykhanh07.github.io/workshop-fcaj/vi/tags/","title":"Tags","tags":[],"description":"","content":""}]